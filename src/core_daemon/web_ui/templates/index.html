<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rvc2api UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  </head>
  <body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col">
    <header class="bg-gray-800 shadow p-4 text-xl font-semibold flex items-center justify-between">
      <span>rvc2api Dashboard</span>
    </header>

    <div class="flex flex-1 overflow-hidden">
      <!-- Sidebar Navigation -->
      <aside id="sidebar" class="w-64 bg-gray-800 p-4 space-y-4 border-r border-gray-700 transition-all duration-300 overflow-y-auto flex flex-col justify-between">
        <div>
          <div class="flex justify-between items-center mb-4">
            <span class="text-lg font-semibold">Navigation</span>
          </div>
          <nav class="space-y-2">
            <button data-view="lights" class="nav-link w-full text-left text-gray-300 hover:text-white">Lights</button>
            <button data-view="logs" class="nav-link w-full text-left text-gray-300 hover:text-white">Logs</button>
            
            <!-- Configuration Section -->
            <div class="pt-2"> 
              <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">
                Configuration Files
              </h3>
              <div class="space-y-1">
                <button data-view="mapping" class="nav-link w-full text-left text-gray-300 hover:text-white pl-4"> 
                  device_mapping.yml
                </button>
                <button data-view="spec" class="nav-link w-full text-left text-gray-300 hover:text-white pl-4"> 
                  rvc.json
                </button>
              </div>
            </div>
            <!-- Unmapped Entries Link -->
            <div class="pt-2">
              <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">
                Troubleshooting
              </h3>
              <div class="space-y-1">
                <button data-view="unmapped" class="nav-link w-full text-left text-gray-300 hover:text-white pl-4">
                  Unmapped Entries
                </button>
              </div>
            </div>
          </nav>
        </div>
        <div class="border-t border-gray-700 pt-4 text-center">
          <button id="toggleSidebar" class="text-gray-400 hover:text-gray-100">
            <i class="mdi mdi-chevron-left"></i> Collapse
          </button>
        </div>
      </aside>

      <!-- Main content area -->
      <main class="flex-1 overflow-y-auto p-6">
        <section id="lights-view" class="view-section">
          <div class="flex items-center justify-between mb-4">
            <h1 class="text-3xl font-bold">RV-C Lights</h1>
            <div>
              <label class="block mb-1 text-sm text-gray-300">
                <i class="mdi mdi-filter-variant mr-1"></i>Filter by Area:
              </label>
              <select id="area-filter" class="bg-gray-900 text-gray-100 border border-gray-700 rounded p-2">
                <option value="All">All</option>
              </select>
            </div>
          </div>
          <div id="light-grid" class="space-y-8">
            <p id="lights-loading-message">Loading lights...</p>
          </div>
        </section>

        <section id="logs-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Live Logs</h1>
          <div class="mb-4 flex flex-wrap gap-4">
            <select id="log-level" class="bg-gray-800 border border-gray-700 text-white rounded p-2">
              <option value="DEBUG">DEBUG</option>
              <option value="INFO" selected>INFO</option>
              <option value="WARNING">WARNING</option>
              <option value="ERROR">ERROR</option>
              <option value="CRITICAL">CRITICAL</option>
            </select>
            <input id="log-search" type="text" placeholder="Search logs..." class="bg-gray-800 border border-gray-700 text-white rounded p-2 flex-1" />
            <button id="log-pause" class="bg-gray-700 hover:bg-gray-600 text-white rounded p-2">Pause</button>
            <button id="log-resume" class="bg-gray-700 hover:bg-gray-600 text-white rounded p-2" disabled>Resume</button>
          </div>
          <pre id="log-stream" class="bg-black text-green-400 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
          <p id="logs-waiting-message" class="text-gray-500 hidden">Waiting for logs...</p>
        </section>

        <section id="mapping-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Current device_mapping.yml</h1>
          <pre id="mapping-content" class="bg-gray-800 text-green-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
        </section>

        <section id="spec-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-2">Current rvc.json</h1>
          <div id="spec-metadata" class="mb-4 text-sm text-gray-400">
            Loading spec metadata...
          </div>
          <pre id="spec-content" class="bg-gray-800 text-blue-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
        </section>

        <!-- Unmapped Entries View -->
        <section id="unmapped-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Unmapped CAN Bus Entries</h1>
          <p class="mb-4 text-gray-400">
            These are CAN messages received by the system that could not be mapped to a known device based on your 
            <code>device_mapping.yml</code>. Use this information to help build out your configuration.
          </p>
          <div id="unmapped-entries-container" class="space-y-6">
            <p id="unmapped-loading-message">Loading unmapped entries...</p>
            <!-- Unmapped entries will be loaded here -->
          </div>
        </section>
      </main>
    </div>

    <script>
      const socket = new WebSocket(`ws://${location.host}/ws`);
      const grid = document.getElementById('light-grid');
      const filter = document.getElementById('area-filter');
      const lightStates = {};
      const lightsLoadingMessage = document.getElementById('lights-loading-message');

      // WebSocket for entity updates
      const entitySocket = new WebSocket(`ws://${location.host}/api/ws`);

      entitySocket.onmessage = (event) => {
        const payload = JSON.parse(event.data);
        if (!payload.entity_id) return;
        // Merge new payload with existing state to preserve all fields
        lightStates[payload.entity_id] = { 
          ...(lightStates[payload.entity_id] || {}), 
          ...payload 
        };
        renderGroupedLights();
      };

      function getCardColor(brightness, isOn) {
        if (!isOn) return 'bg-gray-800';
        const alpha = brightness / 100;
        return `bg-[rgba(234,179,8,${alpha.toFixed(2)})] text-black`;
      }

      function renderCard(entity) {
        const { entity_id, state, value, raw, capabilities = [], friendly_name } = entity;
        const brightness = raw?.operating_status ?? 0;
        const brightnessUI = Math.round(brightness / 2);
        const isOn = state === 'on';
        const colorClass = getCardColor(brightnessUI, isOn);

        const card = document.createElement('div');
        card.className = `rounded-2xl p-4 shadow transition-colors duration-300 ${colorClass} relative group`;
        card.style.cursor = 'pointer';
        card.id = entity_id;
        card.innerHTML = `
          <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
            <i class="mdi mdi-power text-yellow-400"></i>
          </div>
          <h2 class="text-xl font-semibold mb-2">${friendly_name || entity_id}</h2>
          <p class="mb-2 flex items-center"><i class="mdi ${isOn ? 'mdi-lightbulb-on' : 'mdi-lightbulb-off'} mr-1"></i><strong>${state}</strong></p>
          <p class="mb-2 flex items-center"><i class="mdi mdi-brightness-6 mr-1"></i>${brightnessUI}%</p>
          ${capabilities.includes('brightness') ? `<input type="range" min="0" max="100" value="${brightnessUI}" class="w-full slider" />` : ''}
        `;

        card.addEventListener('click', (e) => {
          if (e.target.tagName === 'INPUT') return;
          fetch(`/api/entities/${entity_id}/control`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command: 'toggle' })
          });
        });

        const slider = card.querySelector('input');
        if (slider) {
          slider.addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            fetch(`/api/entities/${entity_id}/control`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ command: 'set', state: 'on', brightness: level })
            });
          });
        }

        return card;
      }

      function renderGroupedLights() {
        grid.innerHTML = '';
        const selected = filter.value;
        const grouped = {};

        for (const entity of Object.values(lightStates)) {
          if (entity.device_type !== 'light') { // Explicitly check if the entity is a light
            continue;
          }
          const area = entity?.suggested_area || 'Unknown';
          if (selected !== 'All' && selected !== area) continue;

          if (!grouped[area]) grouped[area] = [];
          grouped[area].push(entity);
        }

        for (const area of Object.keys(grouped).sort()) {
          const section = document.createElement('div');
          section.innerHTML = `
            <h2 class="text-2xl font-bold mb-1">${area}</h2>
            <div class="border-t border-gray-600 my-2"></div>
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"></div>
          `;
          const sectionGrid = section.querySelector('div.grid');

          grouped[area].forEach(entity => {
            sectionGrid.appendChild(renderCard(entity));
          });

          grid.appendChild(section);
        }
      }

      filter.addEventListener('change', renderGroupedLights);

      // WebSocket for logs - to be initialized when log view is active
      let logSocket = null;
      let isLogPaused = false;
      const logStream = document.getElementById('log-stream');
      const logLevelFilter = document.getElementById('log-level');
      const logSearchInput = document.getElementById('log-search');
      const logsWaitingMessage = document.getElementById('logs-waiting-message');

      function connectLogSocket() {
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
          return;
        }
        logSocket = new WebSocket(`ws://${location.host}/api/ws/logs`);
        logsWaitingMessage.classList.remove('hidden'); // Show waiting message

        logSocket.onopen = () => {
          console.log("Log WebSocket connected");
          logStream.innerHTML = ''; // Clear previous logs on new connection
          // logsWaitingMessage.classList.add('hidden'); // Hide if logs start coming immediately, or keep visible until first message
        };

        logSocket.onmessage = (event) => {
          if (isLogPaused) return;
          logsWaitingMessage.classList.add('hidden'); // Hide waiting message on first log

          const logEntry = event.data;
          const currentLogLevel = logLevelFilter.value.toUpperCase();
          const searchTerm = logSearchInput.value.toLowerCase();

          // Apply log level filter 
          // Assumes log format like: "YYYY-MM-DD HH:MM:SS,ms LEVELNAME LOGGER_NAME: Message"
          const levelMatch = logEntry.match(/^\S+\s+\S+\s+(\w+)/); // Corrected regex
          const entryLogLevel = levelMatch ? levelMatch[1].toUpperCase() : "UNKNOWN";
          
          const logLevels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"];
          const currentFilterIndex = logLevels.indexOf(currentLogLevel);
          const entryLevelIndex = logLevels.indexOf(entryLogLevel);

          if (entryLevelIndex < currentFilterIndex) {
            return; // Skip if entry level is lower than selected filter level
          }

          // Apply search term filter
          if (searchTerm && !logEntry.toLowerCase().includes(searchTerm)) {
            return; // Skip if search term not found
          }

          const logLine = document.createElement('div');
          logLine.textContent = logEntry;
          logStream.appendChild(logLine);
          logStream.scrollTop = logStream.scrollHeight; // Auto-scroll
        };

        logSocket.onerror = (error) => {
          console.error("Log WebSocket error:", error);
          logStream.innerHTML += '<div class="text-red-500">Log WebSocket error. See console for details.</div>';
        };

        logSocket.onclose = () => {
          console.log("Log WebSocket disconnected");
          // Optionally add a message to the UI, or attempt to reconnect
        };
      }

      function disconnectLogSocket() {
        if (logSocket) {
          logSocket.close();
          logSocket = null;
          console.log("Log WebSocket intentionally disconnected");
        }
      }

      // Log controls
      document.getElementById('log-pause').addEventListener('click', () => {
        isLogPaused = true;
        document.getElementById('log-pause').disabled = true;
        document.getElementById('log-resume').disabled = false;
      });

      document.getElementById('log-resume').addEventListener('click', () => {
        isLogPaused = false;
        document.getElementById('log-pause').disabled = false;
        document.getElementById('log-resume').disabled = true;
        logStream.scrollTop = logStream.scrollHeight; // Scroll to bottom on resume
      });
      
      // Re-apply filters when they change
      logLevelFilter.addEventListener('change', () => { 
        logStream.innerHTML = ''; // Clear and let new messages re-populate with new filter
      });
      logSearchInput.addEventListener('input', () => {
        logStream.innerHTML = ''; // Clear and let new messages re-populate with new filter
        // For immediate filtering of existing content (if not clearing), 
        // you'd need to re-evaluate all stored logs, which is more complex.
        // This approach filters new incoming logs.
        if (logSocket && logSocket.readyState === WebSocket.OPEN && logStream.childElementCount === 0) {
            logsWaitingMessage.classList.remove('hidden');
        }
      });


      fetch('/api/lights')
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          lightsLoadingMessage.classList.add('hidden');
          for (const entity of Object.values(data)) {
            lightStates[entity.entity_id] = entity;
          }

          const areas = new Set(Object.values(lightStates).map(e => e?.suggested_area || 'Unknown'));
          for (const area of [...areas].sort()) {
            const opt = document.createElement('option');
            opt.value = area;
            opt.textContent = area;
            filter.appendChild(opt);
          }

          renderGroupedLights();
        })
        .catch(error => {
          console.error("Failed to fetch lights:", error);
          lightsLoadingMessage.textContent = 'Error loading lights. Please check console.';
          lightsLoadingMessage.classList.remove('hidden');
          lightsLoadingMessage.classList.add('text-red-500');
        });

      document.querySelectorAll('.nav-link').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.getAttribute('data-view');
          document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
          const targetView = document.getElementById(`${view}-view`);
          if (targetView) {
            targetView.classList.remove('hidden');
          } else {
            console.error(`View section not found: ${view}-view`);
            return; // Exit if view not found
          }

          // ... (existing log, mapping, spec view logic) ...
          if (view === 'logs') {
            connectLogSocket();
            document.getElementById('log-resume').click(); // Start unpaused
            if (logStream.childElementCount === 0) { // Check if logs view is empty
                logsWaitingMessage.classList.remove('hidden');
            }
          } else {
            disconnectLogSocket();
            logsWaitingMessage.classList.add('hidden'); // Hide waiting message when leaving logs view
          }

          if (view === 'mapping') {
            fetch('/api/config/device_mapping')
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('mapping-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch device_mapping.yml:", err);
                document.getElementById('mapping-content').textContent = `Error: Could not load device_mapping.yml.\n${err.message}`;
              });
          } else if (view === 'spec') {
            fetch('/api/config/rvc_spec')
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('spec-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json:", err);
                document.getElementById('spec-content').textContent = `Error: Could not load rvc.json.\n${err.message}`;
              });
            fetch('/api/config/rvc_spec_metadata')
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.json();
              })
              .then(data => {
                const metadataDiv = document.getElementById('spec-metadata');
                if (data.version && data.spec_document) {
                  metadataDiv.innerHTML = `
                    <p><strong>Version:</strong> ${data.version}</p>
                    <p><strong>Document:</strong> <a href="${data.spec_document}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${data.spec_document}</a></p>
                  `;
                } else {
                  metadataDiv.textContent = 'Could not load spec metadata.';
                }
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json metadata:", err);
                document.getElementById('spec-metadata').textContent = `Error: Could not load spec metadata. ${err.message}`;
              });
          } else if (view === 'unmapped') {
            const container = document.getElementById('unmapped-entries-container');
            const loadingMsg = document.getElementById('unmapped-loading-message');
            loadingMsg.classList.remove('hidden');
            container.innerHTML = ''; // Clear previous entries
            container.appendChild(loadingMsg);

            fetch('/api/unmapped_entries')
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                return response.json();
              })
              .then(data => {
                loadingMsg.classList.add('hidden');
                if (Object.keys(data).length === 0) {
                  container.innerHTML = '<p class="text-gray-500">No unmapped entries found. Good job!</p>';
                  return;
                }

                for (const [key, entry] of Object.entries(data)) {
                  const entryDiv = document.createElement('div');
                  entryDiv.className = 'bg-gray-800 p-4 rounded-lg shadow';
                  
                  let decodedSignalsHtml = 'N/A';
                  if (entry.decoded_signals && Object.keys(entry.decoded_signals).length > 0) {
                    decodedSignalsHtml = '<ul class="list-disc list-inside pl-4 text-sm">';
                    for (const [sigKey, sigValue] of Object.entries(entry.decoded_signals)) {
                      decodedSignalsHtml += `<li><strong>${sigKey}:</strong> ${sigValue}</li>`;
                    }
                    decodedSignalsHtml += '</ul>';
                  } else if (entry.decoded_signals) {
                    decodedSignalsHtml = '<span class="text-gray-500">No signals decoded (PGN might be complex or data invalid).</span>';
                  }

                  const yamlSuggestion = generateYamlSuggestion(entry);

                  entryDiv.innerHTML = `
                    <h3 class="text-xl font-semibold text-yellow-400 mb-2">Unmapped Key: ${key}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-sm mb-3">
                      <p><strong>PGN:</strong> ${entry.pgn_hex}</p>
                      <p><strong>DGN:</strong> ${entry.dgn_hex}</p>
                      <p><strong>Instance:</strong> ${entry.instance}</p>
                      <p><strong>Count:</strong> ${entry.count}</p>
                      <p><strong>First Seen:</strong> ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}</p>
                      <p><strong>Last Seen:</strong> ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}</p>
                      <p class="md:col-span-2"><strong>Last Data Hex:</strong> <code class="text-green-400">${entry.last_data_hex}</code></p>
                    </div>
                    <div class="mb-3">
                      <p class="font-semibold mb-1">Decoded Signals (from PGN ${entry.pgn_hex}):</p>
                      ${decodedSignalsHtml}
                    </div>
                    <div>
                      <p class="font-semibold mb-1">Suggested device_mapping.yml entry:</p>
                      <pre class="bg-gray-900 text-green-300 p-3 rounded overflow-auto text-xs whitespace-pre-wrap"><code class="language-yaml">${yamlSuggestion}</code></pre>
                      <button class="mt-2 bg-blue-600 hover:bg-blue-500 text-white py-1 px-3 rounded text-xs copy-yaml-btn">Copy YAML</button>
                    </div>
                  `;
                  container.appendChild(entryDiv);
                }
                // Add event listeners to new copy buttons
                container.querySelectorAll('.copy-yaml-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const yamlText = event.target.previousElementSibling.querySelector('code').innerText;
                        navigator.clipboard.writeText(yamlText).then(() => {
                            event.target.textContent = 'Copied!';
                            setTimeout(() => { event.target.textContent = 'Copy YAML'; }, 2000);
                        }).catch(err => {
                            console.error('Failed to copy YAML: ', err);
                            event.target.textContent = 'Failed to copy';
                            setTimeout(() => { event.target.textContent = 'Copy YAML'; }, 2000);
                        });
                    });
                });
              })
              .catch(error => {
                console.error('Error fetching unmapped entries:', error);
                loadingMsg.classList.add('hidden');
                container.innerHTML = `<p class="text-red-500">Error loading unmapped entries: ${error.message}</p>`;
              });
          }
        });
      });

      // Function to generate YAML suggestion
      function generateYamlSuggestion(entry) {
        const dgn = entry.dgn_hex;
        const instance = entry.instance;
        const pgn = entry.pgn_hex;
        let suggestedName = `new_device_for_pgn_${pgn}`; 
        if (dgn && dgn !== "PGN_UNKNOWN" && instance !== "N/A") {
            suggestedName = `new_device_for_${dgn}_inst_${instance}`.toLowerCase().replace(/[^a-z0-9_]/g, '_');
        }

        let yaml = `# Suggested entry for PGN: ${pgn}`;
        if (dgn && instance) {
            yaml += `, DGN: ${dgn}, Instance: ${instance}`;
        }
        yaml += `\n# First seen: ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}`;
        yaml += `\n# Last seen: ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}`;
        yaml += `\n# Count: ${entry.count}`;
        yaml += `\n# Last Data: ${entry.last_data_hex}`;

        if (entry.decoded_signals) {
            yaml += `\n# Decoded Signals (from PGN ${pgn}):\n`;
            for (const [key, value] of Object.entries(entry.decoded_signals)) {
                yaml += `#   ${key}: ${value}\n`;
            }
        }

        yaml += `\n- name: "${suggestedName}" # TODO: Change to a unique, descriptive name`;
        if (dgn && dgn !== "PGN_UNKNOWN") {
             yaml += `\n  dgn: "${dgn}"`;
        }
        if (instance !== "N/A") {
            yaml += `\n  instance: ${instance}`;
        }
        yaml += `\n  type: "unknown" # TODO: Specify device type (e.g., light, sensor, tank, hvac)`;
        yaml += `\n  suggested_area: "Default Area" # TODO: Assign an area`;
        yaml += `\n  friendly_name: "New Unmapped Device" # TODO: Set a user-friendly name`;
        yaml += `\n  # capabilities: [] # e.g., [on_off, brightness] for lights, if applicable`;
        yaml += `\n  # command_pgn: "FFFFF" # If controllable, specify the command PGN`;
        yaml += `\n  # command_instance_override: ${instance !== "N/A" ? instance : 0} # Usually same as status instance`;

        return yaml;
      }

      document.getElementById('toggleSidebar').addEventListener('click', () => {
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.toggle('w-64');
        sidebar.classList.toggle('w-0');
        sidebar.classList.toggle('p-4');
        const icon = document.querySelector('#toggleSidebar i');
        icon.classList.toggle('mdi-chevron-left');
        icon.classList.toggle('mdi-chevron-right');
        document.getElementById('toggleSidebar').innerHTML = sidebar.classList.contains('w-0')
          ? '<i class="mdi mdi-chevron-right"></i> Expand'
          : '<i class="mdi mdi-chevron-left"></i> Collapse';
      });
    </script>
  </body>
</html>
