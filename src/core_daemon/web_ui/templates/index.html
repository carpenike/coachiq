<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>rvc2api UI</title>
        <!-- <script src="https://cdn.tailwindcss.com"></script> --> <!-- Moved to end of body -->
        <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css"
              rel="stylesheet">
        <link rel="stylesheet"
              href="{{ url_for('static', path='css/custom.css') }}">
    </head>
    <body class="theme-default bg-gray-900 text-gray-100 min-h-screen flex flex-col antialiased">
        <div id="toast-container"></div>
        <!-- Toast messages will appear here -->
        <header class="bg-gray-800 shadow p-4 text-xl font-semibold flex items-center justify-between sticky top-0 z-50">
            <div class="flex items-center">
                <button id="mobileMenuButton"
                        class="md:hidden text-gray-300 hover:text-white mr-4">
                    <i class="mdi mdi-menu text-2xl"></i>
                </button>
                <span>rvc2api Dashboard</span>
            </div>
            <div class="relative">
                <select id="themeSwitcher"
                        class="bg-gray-700 text-gray-200 text-sm rounded-md p-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="default">Default Theme</option>
                    <option value="dark">Dark Theme</option>
                    <option value="light">Light Theme</option>
                    <option value="catppuccin-mocha">Catppuccin Mocha</option>
                    <option value="catppuccin-latte">Catppuccin Latte</option>
                    <!-- Add more themes here -->
                </select>
            </div>
        </header>
        <div class="flex flex-1 overflow-hidden">
            <!-- Sidebar Navigation -->
            <aside id="sidebar"
                   class="fixed inset-y-0 left-0 z-40 transform -translate-x-full mt-16 md:mt-0 md:fixed md:left-0 md:top-16 md:h-[calc(100vh-4rem)] md:transform-none md:w-64 bg-gray-800 p-4 border-r border-gray-700 transition-all duration-300 ease-in-out flex flex-col justify-between">
                <div id="sidebarNavContent" class="flex-grow overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <span class="text-lg font-semibold">Navigation</span>
                        <button id="closeSidebarButton"
                                class="md:hidden text-gray-400 hover:text-white">
                            <i class="mdi mdi-close text-2xl"></i>
                        </button>
                    </div>
                    <nav class="space-y-2">
                        <button data-view="home"
                                class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700 active-nav">
                            Home
                        </button>
                        <button data-view="lights"
                                class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                            Lights
                        </button>
                        <!-- Removed Logs button from main navigation, will be controlled by pinned bar -->
                        <!-- Configuration Section -->
                        <div class="pt-2">
                            <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">Configuration Files</h3>
                            <div class="space-y-1">
                                <button data-view="mapping"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    device_mapping.yml
                                </button>
                                <button data-view="spec"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    rvc.json
                                </button>
                            </div>
                        </div>
                        <!-- Unmapped Entries Link -->
                        <div class="pt-2">
                            <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">Troubleshooting</h3>
                            <div class="space-y-1">
                                <button data-view="unmapped"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    Unmapped Entries
                                </button>
                                <button data-view="unknown-pgns"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    Unknown PGNs
                                </button>
                            </div>
                        </div>
                    </nav>
                </div>
                <div class="border-t border-gray-700 pt-4 text-center">
                    <button id="toggleSidebarDesktop"
                            class="text-gray-400 hover:text-gray-100 w-full flex items-center justify-center p-2 rounded hover:bg-gray-700">
                        <i class="mdi mdi-chevron-left text-xl"></i> <span class="ml-2">Collapse</span>
                    </button>
                </div>
            </aside>
            <!-- Main content area -->
            <main id="mainContent"
                  class="flex-1 overflow-y-auto p-6 transition-all duration-300 ease-in-out md:ml-64">
                <!-- Removed md:h-[calc(100vh-4rem)] -->
                <!-- Home View / Dashboard -->
                <section id="home-view" class="view-section">
                    <h1 class="text-3xl font-bold mb-8 text-gray-100">Dashboard</h1>
                    <div class="mb-10">
                        <h2 class="text-2xl font-semibold mb-4 text-gray-300">Quick Light Controls</h2>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-4">
                            <!-- Column 1: All Lights -->
                            <div class="space-y-4">
                                <button id="btn-all-on"
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-lightbulb-group-outline mr-2"></i>All Lights On
                                </button>
                                <button id="btn-all-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-lightbulb-group-off-outline mr-2"></i>All Lights Off
                                </button>
                            </div>
                            <!-- Column 2: Exterior Lights -->
                            <div class="space-y-4">
                                <button id="btn-exterior-on"
                                        class="w-full bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-outdoor-lamp mr-2"></i>Exterior On
                                </button>
                                <button id="btn-exterior-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-dome-light mr-2"></i>Exterior Off
                                </button>
                            </div>
                            <!-- Column 3: Interior Lights -->
                            <div class="space-y-4">
                                <button id="btn-interior-on"
                                        class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-home-lightbulb-outline mr-2"></i>Interior On
                                </button>
                                <button id="btn-interior-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-home-lightbulb-off-outline mr-2"></i>Interior Off
                                </button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h2 class="text-2xl font-semibold mb-4 text-gray-300">Scenes</h2>
                        <div class="bg-gray-800 p-6 rounded-lg shadow">
                            <p class="text-gray-400 mb-4">Scene management and definition coming soon.</p>
                            <p class="text-gray-500 text-sm mt-2 mb-4">
                                This section will allow you to define and trigger custom scenes involving multiple devices (lights, locks, etc.).
                            </p>
                            <button id="btn-create-scene"
                                    class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-blue-600"
                                    onclick="alert('Create New Scene button clicked!')">
                                <i class="mdi mdi-plus-circle-outline mr-2"></i>Create New Scene
                            </button>
                        </div>
                    </div>
                    <!-- CAN Bus Status Section -->
                    <div class="mt-10">
                        <h2 class="text-2xl font-semibold mb-6 text-gray-300">System Status</h2>
                        <!-- API Server Status -->
                        <div class="mb-6">
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">API Server</h3>
                            <div id="api-status-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="api-status-loading-message" class="text-gray-400">Loading API server status...</p>
                                <!-- API server status will be loaded here by JavaScript -->
                            </div>
                        </div>
                        <!-- Application Health -->
                        <div class="mb-6">
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">Application Health</h3>
                            <div id="app-health-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="app-health-loading-message" class="text-gray-400">Loading application health...</p>
                                <!-- Application health details (e.g., config load status, connected clients) will be loaded here -->
                            </div>
                        </div>
                        <!-- CAN Bus Status Sub-section -->
                        <div>
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">CAN Bus Interfaces</h3>
                            <div id="can-status-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="can-status-loading-message" class="text-gray-400">Loading CAN status...</p>
                                <!-- CAN status will be loaded here by JavaScript -->
                            </div>
                        </div>
                    </div>
                </section>
                <section id="lights-view" class="view-section hidden">
                    <div class="flex items-center justify-between mb-4">
                        <h1 class="text-3xl font-bold">RV-C Lights</h1>
                        <div>
                            <label class="block mb-1 text-sm text-gray-300">
                                <i class="mdi mdi-filter-variant mr-1"></i>Filter by Area:
                            </label>
                            <select id="area-filter"
                                    class="bg-gray-900 text-gray-100 border border-gray-700 rounded p-2">
                                <option value="All">All</option>
                            </select>
                        </div>
                    </div>
                    <div id="light-grid" class="space-y-8">
                        <p id="lights-loading-message">Loading lights...</p>
                    </div>
                </section>
                <section id="mapping-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Current device_mapping.yml</h1>
                    <pre id="mapping-content"
                         class="bg-gray-800 text-green-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap">Loading device_mapping.yml...</pre>
                </section>
                <section id="spec-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-2">Current rvc.json</h1>
                    <div id="spec-metadata" class="mb-4 text-sm text-gray-400">Loading spec metadata...</div>
                    <pre id="spec-content"
                         class="bg-gray-800 text-blue-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap">Loading rvc.json...</pre>
                </section>
                <!-- Unmapped Entries View -->
                <section id="unmapped-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Unmapped CAN Bus Entries</h1>
                    <p class="mb-4 text-gray-400">
                        These are CAN messages received by the system that could not be mapped to a known device based on your
                        <code>device_mapping.yml</code>. Use this information to help build out your configuration.
                    </p>
                    <div id="unmapped-entries-container" class="space-y-6">
                        <p id="unmapped-loading-message">Loading unmapped entries...</p>
                        <!-- Unmapped entries will be loaded here -->
                    </div>
                </section>
                <!-- Unknown PGNs View -->
                <section id="unknown-pgns-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Unknown PGNs (Not in rvc.json)</h1>
                    <p class="mb-4 text-gray-400">
                        These are CAN messages received by the system where the PGN (extracted from the arbitration ID)
                        was <strong>not found</strong> in your <code>rvc.json</code> specification file. This means the system
                        does not know how to interpret these messages at a fundamental PGN level.
                    </p>
                    <div id="unknown-pgns-container" class="space-y-6">
                        <p id="unknown-pgns-loading-message">Loading unknown PGNs...</p>
                        <!-- Unknown PGNs will be loaded here -->
                    </div>
                </section>
            </main>
        </div>
        <!-- Pinned Logs Container -->
        <div id="pinnedLogsContainer"
             class="fixed bottom-0 left-0 right-0 z-[60] bg-gray-800 border-t border-gray-700 shadow-lg transition-all duration-300 ease-in-out"
             style="height: 3rem">
            <!-- Initial height for collapsed header -->
            <div id="pinnedLogsResizeHandle"
                 class="absolute top-0 left-0 right-0 h-2 cursor-ns-resize"
                 style="z-index: 61"></div>
            <!-- Draggable Resize Handle -->
            <div id="pinnedLogsHeader"
                 class="flex justify-between items-center p-2 h-12 cursor-pointer hover:bg-gray-700">
                <span class="font-semibold text-gray-300 ml-2">Logs</span>
                <button id="togglePinnedLogsBtn" class="text-gray-300 hover:text-white p-1">
                    <i class="mdi mdi-chevron-up text-2xl"></i>
                </button>
            </div>
            <div id="pinnedLogsContent"
                 class="hidden bg-gray-800 px-4 pb-4 pt-2 flex flex-col"
                 style="height: calc(30vh - 3rem)">
                <!-- Removed max-height: 400px -->
                <div class="flex flex-wrap gap-x-4 gap-y-2 mb-3 items-center">
                    <select id="log-level"
                            class="bg-gray-700 border border-gray-600 text-white rounded p-1.5 text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="DEBUG">DEBUG</option>
                        <option value="INFO" selected>INFO</option>
                        <option value="WARNING">WARNING</option>
                        <option value="ERROR">ERROR</option>
                        <option value="CRITICAL">CRITICAL</option>
                    </select>
                    <input id="log-search"
                           type="text"
                           placeholder="Search logs..."
                           class="bg-gray-700 border border-gray-600 text-white rounded p-1.5 text-sm flex-grow min-w-[200px] focus:ring-blue-500 focus:border-blue-500" />
                    <div class="flex gap-2">
                        <button id="log-pause"
                                class="bg-gray-600 hover:bg-gray-500 text-white rounded px-3 py-1.5 text-sm">
                            Pause
                        </button>
                        <button id="log-resume"
                                class="bg-gray-500 hover:bg-gray-400 text-white rounded px-3 py-1.5 text-sm"
                                disabled>Resume</button>
                        <button id="log-clear"
                                class="bg-red-600 hover:bg-red-500 text-white rounded px-3 py-1.5 text-sm">
                            Clear
                        </button>
                        <!-- Added Clear button -->
                    </div>
                </div>
                <pre id="log-stream"
                     class="bg-black text-green-400 p-3 rounded overflow-auto flex-1 min-h-0 font-mono text-xs whitespace-pre-wrap"></pre> <!-- Removed h-full, added flex-1 min-h-0 -->
                <p id="logs-waiting-message"
                   class="text-gray-500 hidden absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
                    Waiting for logs...
                </p>
            </div>
        </div>
        <script>
      // const socket = new WebSocket(`ws://${location.host}/ws`); // This line will be removed
      const grid = document.getElementById('light-grid');
      const filter = document.getElementById('area-filter');
      const lightStates = {};
      const lightsLoadingMessage = document.getElementById('lights-loading-message');
      const apiBasePath = '/api'; // Define base path for API calls

      // CAN Status Elements
      const canStatusContainer = document.getElementById('can-status-container');
      const canStatusLoadingMessage = document.getElementById('can-status-loading-message');

      // API Server Status Elements (New)
      const apiStatusContainer = document.getElementById('api-status-container');
      const apiStatusLoadingMessage = document.getElementById('api-status-loading-message');

      // Application Health Elements (New)
      const appHealthContainer = document.getElementById('app-health-container');
      const appHealthLoadingMessage = document.getElementById('app-health-loading-message');

      // Pinned Logs Elements
      const pinnedLogsContainer = document.getElementById('pinnedLogsContainer');
      const pinnedLogsHeader = document.getElementById('pinnedLogsHeader');
      const togglePinnedLogsBtn = document.getElementById('togglePinnedLogsBtn');
      const pinnedLogsChevronIcon = togglePinnedLogsBtn.querySelector('i');
      const pinnedLogsContent = document.getElementById('pinnedLogsContent');
      const mainContent = document.getElementById('mainContent'); // Already defined, ensure it is

      // Log stream elements (now part of pinnedLogsContent)
      let logSocket = null;
      let isLogPaused = false;
      const logStream = document.getElementById('log-stream');
      const logLevelFilter = document.getElementById('log-level');
      const logSearchInput = document.getElementById('log-search');
      const logsWaitingMessage = document.getElementById('logs-waiting-message');
      const logPauseBtn = document.getElementById('log-pause');
      const logResumeBtn = document.getElementById('log-resume');
      const logClearBtn = document.getElementById('log-clear'); // Get clear button

      const PINNED_LOGS_OPEN_KEY = 'pinnedLogsOpen';
      const PINNED_LOGS_HEIGHT_KEY = 'pinnedLogsHeight';
      const COLLAPSED_LOGS_HEIGHT = '3rem'; // Height of the header bar
      const DEFAULT_EXPANDED_LOGS_HEIGHT_VH = 30; // Default expanded height in vh
      const MIN_LOGS_PANEL_HEIGHT_PX = 80; // Minimum height in pixels (e.g., header + a bit of content)
      const MAX_LOGS_PANEL_HEIGHT_VH_PERCENT = 80; // Max height as % of viewport height
      let currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`; // Store as string like '30vh'
      let isResizingLogs = false;
      let resizeRafId = null; // For requestAnimationFrame
      let pendingResizeHeightPx = 0; // To store height for RAF update
      let originalContainerTransition = ''; // To store original transition style

      // --- START: Add showToast function ---
      function showToast(message, type = 'info', duration = 3000) {
        const toastContainer = document.getElementById('toast-container') || createToastContainer();
        const toast = document.createElement('div');
        toast.className = `p-4 rounded-md shadow-lg text-white`;

        if (type === 'error') {
          toast.classList.add('bg-red-600');
        } else if (type === 'success') {
          toast.classList.add('bg-green-600');
        } else {
          toast.classList.add('bg-blue-600'); // Default to info
        }

        toast.textContent = message;
        toastContainer.appendChild(toast);

        setTimeout(() => {
          toast.classList.add('opacity-0', 'transition-opacity', 'duration-500');
          setTimeout(() => {
            toast.remove();
            if (toastContainer.childElementCount === 0) {
              toastContainer.remove(); // Remove container if no toasts are left
            }
          }, 500);
        }, duration);
      }

      function createToastContainer() {
        let container = document.getElementById('toast-container');
        if (!container) {
          container = document.createElement('div');
          container.id = 'toast-container';
          container.className = 'fixed bottom-5 right-5 space-y-2 z-50';
          document.body.appendChild(container);
        }
        return container;
      }
      // --- END: Add showToast function ---

      // Constants for sidebar widths
      const SIDEBAR_EXPANDED_WIDTH_DESKTOP = '16rem'; // Corresponds to md:w-64
      const SIDEBAR_COLLAPSED_WIDTH_DESKTOP = '4rem';  // Corresponds to md:w-16

      function adjustPinnedLogsLayout() {
        if (!pinnedLogsContainer || !sidebar) return;

        if (window.innerWidth < 768) { // Tailwind 'md' breakpoint (768px)
          // On mobile, sidebar is an overlay or hidden. Logs bar spans full width.
          pinnedLogsContainer.style.left = '0px';
        } else {
          // Desktop view: sidebar is fixed on the left
          const isSidebarCollapsedDesktop = sidebar.classList.contains('md:w-16');
          if (isSidebarCollapsedDesktop) {
            pinnedLogsContainer.style.left = SIDEBAR_COLLAPSED_WIDTH_DESKTOP;
          } else { // Sidebar is expanded (should have md:w-64)
            pinnedLogsContainer.style.left = SIDEBAR_EXPANDED_WIDTH_DESKTOP;
          }
        }
      }

      function setPinnedLogsState(isOpen, height) {
        console.log('[setPinnedLogsState] Called with isOpen:', isOpen, 'Height:', height);
        localStorage.setItem(PINNED_LOGS_OPEN_KEY, isOpen);
        if (isOpen && height) {
          localStorage.setItem(PINNED_LOGS_HEIGHT_KEY, height);
          currentExpandedLogsHeight = height;
        }

        if (isOpen) {
          console.log('[setPinnedLogsState] Opening pinned logs.');
          pinnedLogsContent.classList.remove('hidden');
          pinnedLogsContainer.style.height = currentExpandedLogsHeight;
          pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
          mainContent.style.paddingBottom = currentExpandedLogsHeight;
          pinnedLogsChevronIcon.classList.remove('mdi-chevron-up');
          pinnedLogsChevronIcon.classList.add('mdi-chevron-down');
          console.log('[setPinnedLogsState] Calling connectLogSocket.');
          connectLogSocket();
          if (logStream.childElementCount === 0 && logSocket && logSocket.readyState === WebSocket.OPEN) {
            console.log('[setPinnedLogsState] Showing logsWaitingMessage.');
            logsWaitingMessage.classList.remove('hidden');
          } else {
            // Ensure it's hidden if conditions aren't met or logs are present
            console.log('[setPinnedLogsState] Hiding logsWaitingMessage (or keeping hidden).');
            logsWaitingMessage.classList.add('hidden');
          }
        } else {
          console.log('[setPinnedLogsState] Closing pinned logs.');
          pinnedLogsContent.classList.add('hidden');
          pinnedLogsContainer.style.height = COLLAPSED_LOGS_HEIGHT;
          mainContent.style.paddingBottom = COLLAPSED_LOGS_HEIGHT; // Adjust padding for collapsed bar
          pinnedLogsChevronIcon.classList.remove('mdi-chevron-down');
          pinnedLogsChevronIcon.classList.add('mdi-chevron-up');
          // Consider disconnecting log socket if not needed by any other view,
          // but for a pinned pane, usually keep it connected if user might reopen.
          // For now, let's keep it simple and not disconnect immediately on collapse.
          // disconnectLogSocket(); // Optional: if you want to save resources
          console.log('[setPinnedLogsState] Hiding logsWaitingMessage because panel is closing.');
          logsWaitingMessage.classList.add('hidden');
        }
      }

      togglePinnedLogsBtn.addEventListener('click', () => {
        const isOpen = !pinnedLogsContent.classList.contains('hidden');
        setPinnedLogsState(!isOpen, currentExpandedLogsHeight);
      });
      pinnedLogsHeader.addEventListener('click', (e) => {
        if (e.target === pinnedLogsHeader || e.target === pinnedLogsHeader.querySelector('span')) {
            const isOpen = !pinnedLogsContent.classList.contains('hidden');
            setPinnedLogsState(!isOpen, currentExpandedLogsHeight);
        }
      });

      // Initialize pinned logs state from localStorage
      const savedIsOpen = localStorage.getItem(PINNED_LOGS_OPEN_KEY) === 'true';
      const savedHeight = localStorage.getItem(PINNED_LOGS_HEIGHT_KEY);
      if (savedHeight) {
        // Validate saved height against min/max before applying
        let heightNum = parseFloat(savedHeight);
        const unit = savedHeight.replace(/[\d.-]/g, '');
        if (unit === 'px') {
            heightNum = Math.max(MIN_LOGS_PANEL_HEIGHT_PX, Math.min(heightNum, window.innerHeight * (MAX_LOGS_PANEL_HEIGHT_VH_PERCENT / 100)));
            currentExpandedLogsHeight = `${heightNum}px`;
        } else if (unit === 'vh') {
            heightNum = Math.max((MIN_LOGS_PANEL_HEIGHT_PX / window.innerHeight) * 100, Math.min(heightNum, MAX_LOGS_PANEL_HEIGHT_VH_PERCENT));
            currentExpandedLogsHeight = `${heightNum}vh`;
        } else {
            // default to vh if unit is unknown or invalid
            currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`;
        }
      } else {
        currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`;
      }
      // Set initial state without animation for page load
      const originalTransition = pinnedLogsContainer.style.transition;
      pinnedLogsContainer.style.transition = 'none';
      setPinnedLogsState(savedIsOpen, currentExpandedLogsHeight);
      // Restore transition after initial setup
      // Use a timeout to ensure the no-transition style is applied before restoring it
      setTimeout(() => {
        pinnedLogsContainer.style.transition = originalTransition || 'height 0.3s ease-in-out';
      }, 50);

      // Pinned Logs Resizing Logic
      const pinnedLogsResizeHandle = document.getElementById('pinnedLogsResizeHandle');

      function applyResizeStyles() {
        if (!isResizingLogs) return; // Check if still resizing

        currentExpandedLogsHeight = `${pendingResizeHeightPx}px`;
        pinnedLogsContainer.style.height = currentExpandedLogsHeight;
        pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
        mainContent.style.paddingBottom = currentExpandedLogsHeight;

        resizeRafId = null; // Reset RAF ID
      }

      pinnedLogsResizeHandle.addEventListener('mousedown', (e) => {
        if (!pinnedLogsContent.classList.contains('hidden')) { // Only allow resize if panel is open
          e.preventDefault(); // Prevent text selection or other default actions
          isResizingLogs = true;
          const startY = e.clientY;
          const startHeight = pinnedLogsContainer.offsetHeight; // Get height in pixels

          originalContainerTransition = pinnedLogsContainer.style.transition;
          pinnedLogsContainer.style.transition = 'none'; // Disable transitions during drag

          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'ns-resize';

          const onMouseMove = (moveEvent) => {
            if (!isResizingLogs) return;
            const dy = startY - moveEvent.clientY;
            let newHeightPx = startHeight + dy;

            const maxHeightPx = window.innerHeight * (MAX_LOGS_PANEL_HEIGHT_VH_PERCENT / 100);
            newHeightPx = Math.max(MIN_LOGS_PANEL_HEIGHT_PX, Math.min(newHeightPx, maxHeightPx));

            pendingResizeHeightPx = newHeightPx;

            if (resizeRafId === null) {
              resizeRafId = requestAnimationFrame(applyResizeStyles);
            }
          };

          const onMouseUp = () => {
            if (isResizingLogs) {
              isResizingLogs = false;
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);

              if (resizeRafId !== null) {
                cancelAnimationFrame(resizeRafId);
                resizeRafId = null;
              }

              // Apply the final height directly to ensure it's set before saving
              // This uses the last value of pendingResizeHeightPx calculated in onMouseMove
              currentExpandedLogsHeight = `${pendingResizeHeightPx}px`;
              pinnedLogsContainer.style.height = currentExpandedLogsHeight;
              pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
              mainContent.style.paddingBottom = currentExpandedLogsHeight;

              localStorage.setItem(PINNED_LOGS_HEIGHT_KEY, currentExpandedLogsHeight);

              document.body.style.userSelect = '';
              document.body.style.cursor = '';
              pinnedLogsContainer.style.transition = originalContainerTransition || 'height 0.3s ease-in-out'; // Restore transitions
            }
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
      });

      // WebSocket for entity updates
      const entitySocket = new WebSocket(`ws://${location.host}${apiBasePath}/ws`);

      // --- Fetch and Display CAN Status ---
      async function fetchCanStatus() {
        try {
          const response = await fetch(`${apiBasePath}/can/status`);
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const statusData = await response.json();
          updateCanStatusView(statusData);
        } catch (error) {
          console.error("Failed to fetch CAN status:", error);
          if (canStatusContainer && canStatusLoadingMessage) {
            canStatusLoadingMessage.textContent = 'Failed to load CAN status.';
            canStatusLoadingMessage.classList.remove('hidden');
          } else if (canStatusContainer) {
            canStatusContainer.innerHTML = '<p class="text-red-400">Failed to load CAN status.</p>';
          }
        }
      }

      function updateCanStatusView(statusData) {
        if (!canStatusContainer) return;

        canStatusLoadingMessage.classList.add('hidden'); // Hide loading message
        canStatusContainer.innerHTML = ''; // Clear previous content or loading message

        if (Object.keys(statusData).length === 0) {
          canStatusContainer.innerHTML = '<p class="text-gray-400">No CAN interfaces found or status not available.</p>';
          return;
        }

        const ul = document.createElement('ul');
        ul.className = 'space-y-6'; // Increased spacing between interface cards

        for (const interfaceName in statusData) {
          const iface = statusData[interfaceName];
          const li = document.createElement('li');
          li.className = 'p-5 bg-gray-700 rounded-lg shadow-md'; // Slightly more padding and shadow

          let statusText = iface.state || 'N/A';
          let statusColor = 'text-gray-400'; // Default/unknown

          if (iface.state === 'ERROR-ACTIVE' || iface.state === 'UP' || iface.state === 'RUNNING') {
            statusColor = 'text-green-400'; // Healthy states
          } else if (iface.state === 'ERROR-WARNING') {
            statusColor = 'text-yellow-400'; // Warning state
          } else if (iface.state === 'ERROR-PASSIVE') {
            statusColor = 'text-orange-500'; // Passive error state (more distinct orange)
          } else if (iface.state === 'BUS-OFF' || iface.state === 'DOWN' || iface.state === 'STOPPED') {
            statusColor = 'text-red-500'; // Error/Offline states (more distinct red)
          }

          const bitrateDisplay = iface.bitrate ? `${(iface.bitrate / 1000).toFixed(0)} kbps` : 'N/A';
          const samplePointDisplay = iface.sample_point ? `${(iface.sample_point * 100).toFixed(1)}%` : 'N/A';
          const tqDisplay = iface.tq ? `${iface.tq} ns` : 'N/A';

          li.innerHTML = `
            <h3 class="text-xl font-semibold text-blue-300 mb-4 border-b border-gray-600 pb-2">${interfaceName}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2 text-sm">
              <div>
                <p class="mb-1"><strong>State:</strong> <span class="${statusColor} font-semibold">${statusText}</span></p>
                <p class="mb-1"><strong>Bitrate:</strong> ${bitrateDisplay}</p>
                <p class="mb-1"><strong>Sample Point:</strong> ${samplePointDisplay}</p>
                <p class="mb-1"><strong>Restart MS:</strong> ${iface.restart_ms === undefined ? 'N/A' : iface.restart_ms}</p>
              </div>
              <div>
                <p class="mb-1"><strong>TQ:</strong> ${tqDisplay}</p>
                <p class="mb-1"><strong>BRP:</strong> ${iface.brp === undefined ? 'N/A' : iface.brp}</p>
                <p class="mb-1"><strong>Prop Seg:</strong> ${iface.prop_seg === undefined ? 'N/A' : iface.prop_seg}</p>
                <p class="mb-1"><strong>Phase Seg1:</strong> ${iface.phase_seg1 === undefined ? 'N/A' : iface.phase_seg1}</p>
                <p class="mb-1"><strong>Phase Seg2:</strong> ${iface.phase_seg2 === undefined ? 'N/A' : iface.phase_seg2}</p>
                <p class="mb-1"><strong>SJW:</strong> ${iface.sjw === undefined ? 'N/A' : iface.sjw}</p>
              </div>

              ${ (iface.tx_packets !== undefined || iface.rx_packets !== undefined || iface.tx_errors !== undefined || iface.restarts !== undefined) ? `
                <div class="md:col-span-2 mt-3 pt-3 border-t border-gray-600">
                  <h4 class="text-md font-medium text-gray-300 mb-2">Counters & Errors</h4>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-1">
                    <p><strong>TX Packets:</strong> ${iface.tx_packets === undefined ? 'N/A' : iface.tx_packets}</p>
                    <p><strong>RX Packets:</strong> ${iface.rx_packets === undefined ? 'N/A' : iface.rx_packets}</p>
                    <p><strong>TX Bytes:</strong> ${iface.tx_bytes === undefined ? 'N/A' : iface.tx_bytes}</p>
                    <p><strong>RX Bytes:</strong> ${iface.rx_bytes === undefined ? 'N/A' : iface.rx_bytes}</p>
                    <p><strong>TX Errors:</strong> ${iface.tx_errors === undefined ? 'N/A' : iface.tx_errors}</p>
                    <p><strong>RX Errors:</strong> ${iface.rx_errors === undefined ? 'N/A' : iface.rx_errors}</p>
                    <p><strong>Bus Errors:</strong> ${iface.bus_errors === undefined ? 'N/A' : iface.bus_errors}</p>
                    <p><strong>Restarts:</strong> ${iface.restarts === undefined ? 'N/A' : iface.restarts}</p>
                  </div>
                </div>
              ` : ''}

              ${ (iface.parentbus || iface.parentdev) ? `
                <div class="md:col-span-2 mt-3 pt-3 border-t border-gray-600">
                  <h4 class="text-md font-medium text-gray-300 mb-2">Device Info</h4>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-1">
                    <p><strong>Parent Bus:</strong> ${iface.parentbus || 'N/A'}</p>
                    <p><strong>Parent Dev:</strong> ${iface.parentdev || 'N/A'}</p>
                  </div>
                </div>
              ` : ''}
            </div>
          `;
          ul.appendChild(li);
        }
        canStatusContainer.appendChild(ul);
      }

      // --- Fetch and Display API Server Status (NEW) ---
      async function fetchApiServerStatus() {
        if (!apiStatusContainer) return;
        apiStatusLoadingMessage.classList.remove('hidden'); // Show loading message
        try {
          const response = await fetch(`${apiBasePath}/status/server`);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }
          const statusData = await response.json();
          updateApiServerView(statusData);
        } catch (error) {
          console.error("Failed to fetch API server status:", error);
          if (apiStatusLoadingMessage) { // Check if it wasn't cleared by a successful load
            apiStatusLoadingMessage.textContent = 'Failed to load API server status.';
          }
          // Display error in the container itself if loading message is already gone or not primary
          apiStatusContainer.innerHTML = `<p class="text-red-400">Failed to load API server status: ${error.message}</p>`;
        } finally {
            if (apiStatusLoadingMessage) apiStatusLoadingMessage.classList.add('hidden'); // Hide loading message
        }
      }

      function updateApiServerView(statusData) {
        if (!apiStatusContainer) return;
        apiStatusContainer.innerHTML = `
          <ul class="space-y-2 text-sm">
            <li><strong>Version:</strong> ${statusData.version || 'N/A'}</li>
            <li><strong>Uptime:</strong> ${statusData.uptime || 'N/A'}</li>
            <li><strong>Requests Processed:</strong> ${statusData.requests_processed || 'N/A'}</li>
            <li><strong>Error Rate:</strong> ${statusData.error_rate || 'N/A'}</li>
          </ul>
        `;
      }

      // --- Fetch and Display Application Health (NEW) ---
      async function fetchApplicationHealth() {
        if (!appHealthContainer) return;
        appHealthLoadingMessage.classList.remove('hidden'); // Show loading message
        try {
          const response = await fetch(`${apiBasePath}/status/application`);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }
          const healthData = await response.json();
          updateApplicationHealthView(healthData);
        } catch (error) {
          console.error("Failed to fetch application health:", error);
          if (appHealthLoadingMessage) { // Check if it wasn't cleared
            appHealthLoadingMessage.textContent = 'Failed to load application health.';
          }
          appHealthContainer.innerHTML = `<p class="text-red-400">Failed to load application health: ${error.message}</p>`;
        } finally {
            if (appHealthLoadingMessage) appHealthLoadingMessage.classList.add('hidden'); // Hide loading message
        }
      }

      function updateApplicationHealthView(healthData) {
        if (!appHealthContainer) return;
        appHealthContainer.innerHTML = `
          <ul class="space-y-2 text-sm">
            <li><strong>Configuration Files Loaded:</strong> <span class="${healthData.config_files_loaded ? 'text-green-400' : 'text-red-400'}">${healthData.config_files_loaded ? 'Yes' : 'No'}</span></li>
            <li><strong>Active WebSocket Clients:</strong> ${healthData.websocket_clients === undefined ? 'N/A' : healthData.websocket_clients}</li>
            <li><strong>Last Critical Error:</strong> ${healthData.last_error || 'N/A'}</li>
            <!-- Add more application-specific health indicators here -->
          </ul>
        `;
      }

      // Helper function to call light services (or any entity control)
      function callLightService(entityId, command, data = {}) {
        let path;
        let body;
        const groupLightEntityIds = ['all_lights', 'exterior_lights', 'interior_lights']; // Add other group IDs if any

        if (groupLightEntityIds.includes(entityId)) {
          // This is a group control command
          const groupName = entityId.replace('_lights', ''); // e.g. all_lights -> all
          path = `${apiBasePath}/lights/control?group=${groupName}`;
          body = { command: command, ...data }; // Pass command and any relevant data (state, brightness)

          // Validate group commands (optional, but good practice for clarity)
          const validGroupCommands = ['set', 'toggle', 'brightness_up', 'brightness_down'];
          if (!validGroupCommands.includes(command)) {
            console.error(`Invalid command '${command}' for group light control '${entityId}'.`);
            showToast(`Invalid command for group ${entityId}`, 'error');
            return Promise.reject(`Invalid command for group ${entityId}`);
          }
          if (command === 'set' && data.state === undefined && data.brightness === undefined) {
            console.warn(`'set' command for group ${entityId} called without state or brightness.`);
            // Allow it, backend might handle it or have defaults, but it's unusual.
          }

        } else {
          // This is an individual entity control command
          path = `${apiBasePath}/entities/${entityId}/control`;
          body = { command: command, ...data }; // Standard body for entity control

          // Validate individual commands
          const validIndividualCommands = ['set', 'toggle', 'brightness_up', 'brightness_down'];
          if (!validIndividualCommands.includes(command)) {
            console.error('Unknown light command for individual entity:', command);
            showToast(`Unknown command: ${command} for ${entityId}`, 'error');
            return Promise.reject(`Unknown command: ${command} for ${entityId}`);
          }
        }

        return fetch(path, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(response => {
          if (!response.ok) {
            return response.json().then(err => {
              const errorMsg = `HTTP error ${response.status}: ${err.detail || response.statusText}`;
              console.error(`Service call for ${entityId} (${command}) failed:`, errorMsg, err);
              throw new Error(errorMsg);
            });
          }
          return response.json();
        })
        .then(responseData => {
          console.log(`Command ${command} for ${entityId} successful:`, responseData);
          // UI should update via WebSocket message triggering renderGroupedLights()
          // Or, if optimistic updates are desired, handle here.
        })
        .catch(error => {
          console.error(`Command ${command} for ${entityId} failed:`, error);
          showToast(`Failed to control ${entityId}: ${error.message}`, 'error');
        });
      }

      function renderCard(entity) {
        const card = document.createElement('div');
        card.className = 'p-4 rounded-lg shadow-md space-y-3 entity-card'; // Base classes
        card.dataset.entityId = entity.entity_id;

        const friendlyName = entity.friendly_name || entity.entity_id;
        let state = entity.state || 'unknown'; // 'on' or 'off'
        const raw_attrs = entity.raw || {}; // Use entity.raw for raw CAN values
        const capabilities = entity.capabilities || [];

        // Apply on/off class for styling
        if (state.toLowerCase() === 'on') {
          card.classList.add('light-on');
          card.classList.remove('light-off');
        } else {
          card.classList.add('light-off');
          card.classList.remove('light-on');
        }

        let cardContent = `<h3 class="text-lg font-semibold">${friendlyName}</h3>`;

        // const hasOnOff = capabilities.includes('on_off'); // Not needed for separate buttons anymore
        const hasBrightness = capabilities.includes('brightness');

        if (hasBrightness) {
          // Brightness is determined from entity.raw.operating_status (typically 0-200 from CAN).
          // This needs to be converted to a 0-100% scale for the UI slider.
          // Max CAN brightness for 100% is 0xC8 (200).
          let currentBrightnessPercent = 0;
          if (state.toLowerCase() === 'on') {
            if (raw_attrs.operating_status !== undefined) {
                // raw_attrs.operating_status is the CAN level (e.g. 0-200 where 200 is 100%)
                // Map this to a 0-100 scale for the slider.
                // Max CAN brightness for 100% is 0xC8 (200).
                currentBrightnessPercent = Math.min(Math.round((parseInt(raw_attrs.operating_status, 10) / 200) * 100), 100);
            } else {
                currentBrightnessPercent = 100; // Default to 100% if on and no brightness attribute
            }
          }

          cardContent += `
            <div class="brightness-control space-y-1 pt-2">
              <label for="br-${entity.entity_id}" class="text-sm">Brightness: <span id="br-val-${entity.entity_id}">${currentBrightnessPercent}%</span></label>
              <input type="range" id="br-${entity.entity_id}" data-entity-id="${entity.entity_id}" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer brightness-slider" min="0" max="100" value="${currentBrightnessPercent}">
            </div>
          `;
        }

        card.innerHTML = cardContent;

        // Make the entire card clickable to toggle on/off
        card.addEventListener('click', (e) => {
          // Prevent toggle if the click was on the slider itself or its label
          if (e.target.closest('.brightness-control')) {
            return;
          }
          const entityId = card.dataset.entityId;
          // Determine current state for toggle logic if needed, or just send 'toggle'
          // const currentLightState = lightStates[entityId]?.state || 'off';
          // callLightService(entityId, 'set', { state: currentLightState === 'on' ? 'off' : 'on' });
          callLightService(entityId, 'toggle');
        });

        if (hasBrightness) {
          const slider = card.querySelector('.brightness-slider');
          const brightnessValueDisplay = card.querySelector(`#br-val-${entity.entity_id}`);
          if (slider) {
            slider.addEventListener('input', (e) => {
              const brightness = parseInt(e.target.value, 10); // 0-100
              if (brightnessValueDisplay) brightnessValueDisplay.textContent = `${brightness}%`;
            });
            slider.addEventListener('change', (e) => { // 'change' event fires when user releases mouse
              const entityId = e.target.dataset.entityId;
              const brightness = parseInt(e.target.value, 10); // 0-100
              // When setting brightness, the light should be 'on'.
              // The API's /control endpoint handles this: if brightness is set, state 'on' is implied or can be sent.
              callLightService(entityId, 'set', { state: 'on', brightness: brightness });
            });
          }
        }
        return card;
      }

      entitySocket.onmessage = (event) => {
        const entityData = JSON.parse(event.data);
        const entity_id = entityData.entity_id;

        if (entity_id) {
          // If the entity is already in lightStates (i.e., it's a light we are displaying), update it.
          if (lightStates.hasOwnProperty(entity_id)) {
            lightStates[entity_id] = entityData;
            renderGroupedLights();
          }
          // If it's a new entity that is a light (e.g., identified after initial load),
          // add it to lightStates and render.
          else if (entityData.device_type === 'light') {
            lightStates[entity_id] = entityData;
            // Check if its area needs to be added to the filter
            const area = entityData.suggested_area || 'Unknown';
            const areaFilter = document.getElementById('area-filter');
            if (areaFilter) {
              const existingOptions = Array.from(areaFilter.options).map(opt => opt.value);
              if (!existingOptions.includes(area)) {
                const opt = document.createElement('option');
                opt.value = area;
                opt.textContent = area;
                areaFilter.appendChild(opt);
                // Consider sorting filter options if many areas are dynamically added
              }
            }
            renderGroupedLights();
          }
        }
      };

      function renderGroupedLights() {
        console.log('renderGroupedLights called. lightStates:', JSON.parse(JSON.stringify(lightStates)), 'Filter:', filter ? filter.value : 'N/A');
        if (!grid) {
          console.error('renderGroupedLights: grid element not found!');
          return;
        }

        const lightsLoadingP = document.getElementById('lights-loading-message');
        if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
        }

        grid.innerHTML = ''; // Clear previous content (cards, "No lights" message, etc.)

        const selectedAreaFilter = filter.value;
        const groupedByArea = {};
        let lightsExistToDisplay = false;

        // Group lights by area, applying the filter
        for (const entityId in lightStates) {
          const entity = lightStates[entityId];
          if (entity.device_type === 'light') {
            const area = entity.suggested_area || 'Unknown';
            if (selectedAreaFilter === 'All' || selectedAreaFilter === area) {
              if (!groupedByArea[area]) {
                groupedByArea[area] = [];
              }
              groupedByArea[area].push(entity);
              lightsExistToDisplay = true;
            }
          }
        }

        if (!lightsExistToDisplay) {
          const messageP = document.createElement('p');
          messageP.className = 'text-gray-500 text-center py-8';
          if (Object.keys(lightStates).length === 0 && (!filter.value || filter.value === 'All')) {
            messageP.textContent = 'No lights are currently configured or available.';
            console.log('renderGroupedLights: Displaying "No lights configured" message.');
          } else {
            messageP.textContent = `No lights found for the current filter ("${selectedAreaFilter}").`;
            console.log(`renderGroupedLights: Displaying "No lights found for filter: ${selectedAreaFilter}" message.`);
          }
          grid.appendChild(messageP);
          return;
        }

        const sortedAreas = Object.keys(groupedByArea).sort();

        for (const areaName of sortedAreas) {
          const areaSectionDiv = document.createElement('div');
          areaSectionDiv.className = 'area-section mb-8';
          areaSectionDiv.dataset.areaName = areaName;

          const areaTitleH2 = document.createElement('h2');
          areaTitleH2.className = 'text-2xl font-semibold mb-3 text-gray-200';
          areaTitleH2.textContent = areaName;
          areaSectionDiv.appendChild(areaTitleH2);

          const dividerDiv = document.createElement('div');
          dividerDiv.className = 'border-t border-gray-700 mb-6';
          areaSectionDiv.appendChild(dividerDiv);

          const entitiesGridDiv = document.createElement('div');
          entitiesGridDiv.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 entity-grid';
          areaSectionDiv.appendChild(entitiesGridDiv);

          groupedByArea[areaName].forEach(entity => {
            try {
              const cardElement = renderCard(entity);
              if (cardElement) {
                entitiesGridDiv.appendChild(cardElement);
              } else {
                console.warn(`renderCard for entity ${entity.entity_id} returned null or undefined.`);
                const errorCardPlaceholder = document.createElement('div');
                errorCardPlaceholder.className = 'p-4 rounded-lg shadow-md entity-card bg-yellow-700 text-white';
                errorCardPlaceholder.textContent = `Could not render ${entity.friendly_name || entity.entity_id}. See console.`;
                entitiesGridDiv.appendChild(errorCardPlaceholder);
              }
            } catch (e) {
              console.error(`Error rendering card for entity ${entity.entity_id} (Area: ${areaName}):`, e);
              const errorCardPlaceholder = document.createElement('div');
              errorCardPlaceholder.className = 'p-4 rounded-lg shadow-md entity-card bg-red-800 text-white';
              errorCardPlaceholder.textContent = `Error loading ${entity.friendly_name || entity.entity_id}. Check console.`;
              entitiesGridDiv.appendChild(errorCardPlaceholder);
            }
          });
          grid.appendChild(areaSectionDiv);
        }
        console.log('renderGroupedLights: Finished rendering areas and cards.');
      }

      // Fetch initial light states
      fetch(`${apiBasePath}/lights`)
        .then(res => {
          if (!res.ok) {
            return res.text().then(text => {
              throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}. Response: ${text}`);
            });
          }
          return res.json();
        })
        .then(data => {
          const lightsLoadingP = document.getElementById('lights-loading-message');
          if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
          }
          if (data && Array.isArray(data)) {
            data.forEach(entity => {
              if (entity.device_type === 'light') {
                lightStates[entity.entity_id] = entity;
                const area = entity.suggested_area || 'Unknown';
                const areaFilter = document.getElementById('area-filter');
                if (areaFilter) {
                    const existingOptions = Array.from(areaFilter.options).map(opt => opt.value);
                    if (!existingOptions.includes(area)) {
                        const opt = document.createElement('option');
                        opt.value = area;
                        opt.textContent = area;
                        areaFilter.appendChild(opt);
                    }
                }
              }
            });
          } else if (data) {
            console.warn("Received non-array data for lights:", data);
          }
          renderGroupedLights();
        })
        .catch(error => {
          console.error("Failed to fetch lights:", error);
          const lightsLoadingP = document.getElementById('lights-loading-message');
          if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
          }
          if (grid) {
            grid.innerHTML = `<p class="text-red-500 text-center py-8">Error loading lights: ${error.message}. Check console for details.</p>`;
          }
        });

      document.querySelectorAll('.nav-link').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.getAttribute('data-view');

          // If a main view navigation occurs, and logs are open, ensure logs remain visible
          // The pinned log pane is independent of view sections now.

          document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
          const targetView = document.getElementById(`${view}-view`);
          if (targetView) {
            targetView.classList.remove('hidden');
          } else {
            console.error(`View section not found: ${view}-view`);
            const homeViewFallback = document.getElementById('home-view');
            if (homeViewFallback) homeViewFallback.classList.remove('hidden');
            // If home is fallback, ensure its nav link is active
            const homeNavLinkFallback = document.querySelector('.nav-link[data-view="home"]');
            if (homeNavLinkFallback) {
                document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
                homeNavLinkFallback.classList.add('active-nav');
            }
            return;
          }

          document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
          btn.classList.add('active-nav');

          // Remove specific logic for 'logs' view as it's now pinned
          // if (view === 'logs') { ... } else { disconnectLogSocket(); ... }

          if (view === 'mapping') {
            fetch(`${apiBasePath}/config/device_mapping`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('mapping-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch device_mapping.yml:", err);
                document.getElementById('mapping-content').textContent = `Error: Could not load device_mapping.yml.\n${err.message}`;
              });
          } else if (view === 'spec') {
            fetch(`${apiBasePath}/config/rvc_spec`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('spec-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json:", err);
                document.getElementById('spec-content').textContent = `Error: Could not load rvc.json.\n${err.message}`;
              });
            fetch(`${apiBasePath}/config/rvc_spec_metadata`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.json();
              })
              .then(data => {
                const metadataDiv = document.getElementById('spec-metadata');
                if (data.version && data.spec_document) {
                  metadataDiv.innerHTML = `
                    <p><strong>Version:</strong> ${data.version}</p>
                    <p><strong>Document:</strong> <a href="${data.spec_document}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${data.spec_document}</a></p>
                  `;
                } else if (data.spec_document) { // Case where only document is present
                  metadataDiv.innerHTML = `
                    <p><strong>Document:</strong> <a href="${data.spec_document}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${data.spec_document}</a></p>
                  `;
                }
                else {
                  metadataDiv.textContent = 'Could not load spec metadata.';
                }
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json metadata:", err);
                document.getElementById('spec-metadata').textContent = `Error: Could not load spec metadata. ${err.message}`;
              });
          } else if (view === 'unmapped') {
            const container = document.getElementById('unmapped-entries-container');
            const loadingMsg = document.getElementById('unmapped-loading-message');
            loadingMsg.classList.remove('hidden');
            container.innerHTML = ''; // Clear previous entries
            container.appendChild(loadingMsg);

            fetch(`${apiBasePath}/unmapped_entries`)
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                return response.json();
              })
              .then(data => {
                loadingMsg.classList.add('hidden');
                if (Object.keys(data).length === 0) {
                  container.innerHTML = '<p class="text-gray-500">No unmapped entries found. Good job!</p>';
                  return;
                }

                for (const [key, entry] of Object.entries(data)) {
                  const entryDiv = document.createElement('div');
                  entryDiv.className = 'bg-gray-800 p-4 rounded-lg shadow';

                  let decodedSignalsHtml = 'N/A';
                  if (entry.decoded_signals && Object.keys(entry.decoded_signals).length > 0) {
                    decodedSignalsHtml = '<ul>'; // Initialize list
                    for (const [sigName, sigValue] of Object.entries(entry.decoded_signals)) {
                      decodedSignalsHtml += `<li class="text-xs"><span class="font-semibold">${sigName}:</span> ${sigValue}</li>`;
                    }
                    decodedSignalsHtml += '</ul>';
                  } else if (entry.decoded_signals) { // If exists but empty
                    decodedSignalsHtml = '<span class="text-xs text-gray-500">No signals decoded for this PGN.</span>';
                  }

                  let suggestionsHtml = '';
                  if (entry.suggestions && entry.suggestions.length > 0) {
                    suggestionsHtml = '<h4 class="text-sm font-semibold mt-2 mb-1">Mapping Suggestions:</h4><ul>';
                    entry.suggestions.forEach(sugg => {
                      suggestionsHtml += `<li class="text-xs">${sugg.message} (Priority: ${sugg.priority})</li>`;
                    });
                    suggestionsHtml += '</ul>';
                  }

                  const yamlSuggestion = generateYamlSuggestion(entry);

                  entryDiv.innerHTML = `
                    <div class="flex justify-between items-start">
                      <div>
                        <h3 class="text-lg font-semibold text-blue-300">DGN: ${entry.dgn_hex} (Instance: ${entry.instance})</h3>
                        ${entry.pgn_hex && entry.pgn_hex !== entry.dgn_hex ? `<p class="text-xs text-gray-400">PGN (from ArbID): ${entry.pgn_hex}</p>` : ''}
                        ${entry.dgn_name ? `<p class="text-sm text-gray-300">DGN Name: ${entry.dgn_name}</p>` : ''}
                        ${entry.pgn_name && entry.pgn_name !== entry.dgn_name ? `<p class="text-sm text-gray-300">PGN Name: ${entry.pgn_name}</p>` : ''}
                      </div>
                      <button class="copy-yaml-btn text-xs bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded" title="Copy YAML to clipboard">
                        <i class="mdi mdi-content-copy"></i> Copy YAML
                      </button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2 text-xs">
                      <div>
                        <p><strong>Last Data:</strong> ${entry.last_data_hex}</p>
                        <p><strong>Count:</strong> ${entry.count}</p>
                      </div>
                      <div>
                        <p><strong>First Seen:</strong> ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}</p>
                        <p><strong>Last Seen:</strong> ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}</p>
                      </div>
                    </div>
                    <div class="mt-2">
                      <h4 class="text-sm font-semibold mb-1">Decoded Signals (PGN: ${entry.pgn_hex || 'N/A'}):</h4>
                      <div class="text-gray-400">${decodedSignalsHtml}</div>
                    </div>
                    ${suggestionsHtml}
                    <div class="mt-3">
                      <h4 class="text-sm font-semibold">Suggested device_mapping.yml entry:</h4>
                      <pre class="bg-gray-900 text-green-300 p-2 rounded-md overflow-x-auto text-xs whitespace-pre-wrap">${yamlSuggestion}</pre>
                    </div>
                  `;
                  container.appendChild(entryDiv);
                }
                // Add event listeners to new copy buttons
                container.querySelectorAll('.copy-yaml-btn').forEach(button => {
                  button.addEventListener('click', (e) => {
                    const preElement = e.target.closest('.bg-gray-800').querySelector('pre');
                    if (preElement) {
                      navigator.clipboard.writeText(preElement.textContent)
                        .then(() => showToast('YAML copied to clipboard!', 'success'))
                        .catch(err => {
                          console.error('Failed to copy YAML: ', err);
                          showToast('Failed to copy YAML.', 'error');
                        });
                    }
                  });
                });
              })
              .catch(error => {
                console.error('Error fetching unmapped entries:', error);
                loadingMsg.classList.add('hidden');
                container.innerHTML = `<p class="text-red-500">Error loading unmapped entries: ${error.message}</p>`;
              });
          }
          // --- START: Add logic for Unknown PGNs view ---
          else if (view === 'unknown-pgns') {
            const container = document.getElementById('unknown-pgns-container');
            const loadingMsg = document.getElementById('unknown-pgns-loading-message');
            loadingMsg.classList.remove('hidden');
            container.innerHTML = ''; // Clear previous entries
            container.appendChild(loadingMsg);

            fetch(`${apiBasePath}/unknown_pgns`)
              .then(response => {
                if (!response.ok) { // Check if response is ok
                  throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                return response.json();
              })
              .then(data => {
                loadingMsg.classList.add('hidden');
                if (Object.keys(data).length === 0) {
                  container.innerHTML = '<p class="text-gray-500">No unknown PGNs found. All observed PGNs are in rvc.json.</p>';
                  return;
                }

                for (const [arbIdHex, entry] of Object.entries(data)) {
                  const entryDiv = document.createElement('div');
                  entryDiv.className = 'bg-gray-800 p-4 rounded-lg shadow';
                  entryDiv.innerHTML = `
                    <h3 class="text-lg font-semibold text-orange-300">Arbitration ID: ${arbIdHex}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2 text-xs">
                      <div>
                        <p><strong>Last Data:</strong> ${entry.last_data_hex}</p>
                        <p><strong>Count:</strong> ${entry.count}</p>
                      </div>
                      <div>
                        <p><strong>First Seen:</strong> ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}</p>
                        <p><strong>Last Seen:</strong> ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}</p>
                      </div>
                    </div>
                    <p class="text-xs mt-2 text-gray-400">This PGN (extracted from the arbitration ID) was not found in the rvc.json specification file.</p>
                  `;
                  container.appendChild(entryDiv);
                }
              })
              .catch(error => {
                console.error('Error fetching unknown PGNs:', error);
                loadingMsg.classList.add('hidden');
                container.innerHTML = `<p class="text-red-500">Error loading unknown PGNs: ${error.message}</p>`;
              });
            }
          // --- END: Add logic for Unknown PGNs view ---
          // Add this else if block to handle fetching CAN status when home is selected
          else if (view === 'home') {
            fetchCanStatus(); // Re-fetch CAN status when navigating to home
          }
        });
      });

      // Function to generate YAML suggestion
      function generateYamlSuggestion(entry) {
        const dgnKey = entry.dgn_hex; // Use DGN for the mapping file key
        const instanceKey = String(entry.instance); // Instance ID

        // Create a sanitized entity_id suggestion
        const dgnForId = dgnKey.toLowerCase();
        const instanceForId = instanceKey.toLowerCase().replace(/[^a-z0-9_]/g, ''); // Basic sanitize
        let suggestedEntityId = `unmapped_${dgnForId}_inst${instanceForId}`;

        let yaml = `# Suggested entry for DGN: ${dgnKey}${entry.dgn_name ? ' (' + entry.dgn_name + ')' : ''}, Instance: ${instanceKey}\n`;
        if (entry.pgn_hex && entry.pgn_hex !== entry.dgn_hex) {
          yaml += `# Original PGN from Arbitration ID: ${entry.pgn_hex}${entry.pgn_name ? ' (' + entry.pgn_name + ')' : ''}\n`;
        }
        yaml += `# First seen: ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}\n`;
        yaml += `# Last seen: ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}\n`;
        yaml += `# Count: ${entry.count}\n`;
        yaml += `# Last Data: ${entry.last_data_hex}\n`;

        if (entry.decoded_signals && Object.keys(entry.decoded_signals).length > 0) {
          yaml += `# Decoded Signals (from PGN ${entry.pgn_hex}):\n`;
          for (const [key, value] of Object.entries(entry.decoded_signals)) {
            yaml += `#   ${key}: ${value}\n`;
          }
        }
        if (entry.spec_entry && entry.spec_entry.name) {
            yaml += `# Matched Spec Entry Name (for DGN): ${entry.spec_entry.name}\n`;
        }
        yaml += `\n`; // Blank line for readability before the YAML structure

        // Start of the structured YAML suggestion
        yaml += `${dgnKey}:\n`;
        yaml += `  ${instanceKey}:\n`; // Instance ID as a key (e.g., 255: or "default":)
        yaml += `    - entity_id: "${suggestedEntityId}" # TODO: MUST be unique. Change to a descriptive name (e.g., 'living_room_thermostat')\n`;
        yaml += `      friendly_name: "Unmapped ${entry.dgn_name || dgnKey} Inst ${instanceKey}" # TODO: Set a user-friendly name (e.g., 'Living Room Thermostat')\n`;
        yaml += `      suggested_area: "Unknown Area" # TODO: Assign an area (e.g., 'Living Room', 'Bedroom')\n`;
        yaml += `      device_type: "unknown" # TODO: Specify type (e.g., light, sensor, hvac, lock, switch, tank)\n`;
        yaml += `      capabilities: [] # TODO: Define capabilities (e.g., [on_off], [on_off, brightness], [lock_unlock], [temperature])\n`;
        yaml += `      # --- Optional fields based on device_type and system needs ---\n`;
        yaml += `      # interface: canX # TODO: Specify CAN interface if known (e.g., can0, can1)\n`;
        yaml += `      # status_dgn: '${dgnKey}' # Status DGN is typically this DGN key\n`;
        yaml += `      # command_pgn: 'YYYYY' # TODO: If controllable and different from status DGN, specify command PGN\n`;
        yaml += `      # group_mask: '0xXX' # TODO: If part of a command/status group\n`;
        yaml += `      # --- Example for using a YAML template (if defined in your mapping file) ---\n`;
        yaml += `      # <<: *switchable_light  # For on/off lights, if &switchable_light template exists\n`;
        yaml += `      # <<: *dimmable_light   # For dimmable lights, if &dimmable_light template exists\n`;

        return yaml;
      }

      // Sidebar toggle logic
      const sidebar = document.getElementById('sidebar');
      const mobileMenuButton = document.getElementById('mobileMenuButton');
      const closeSidebarButton = document.getElementById('closeSidebarButton');
      const toggleSidebarDesktopButton = document.getElementById('toggleSidebarDesktop');
      const desktopSidebarVisibleKey = 'desktopSidebarVisible';
      const sidebarNavContent = document.getElementById('sidebarNavContent');

      function setDesktopSidebarVisible(visible) {
        console.log('[setDesktopSidebarVisible] Called with visible:', visible);
        localStorage.setItem(desktopSidebarVisibleKey, visible);
        if (visible) { // EXPANDING
          console.log('[setDesktopSidebarVisible] Expanding sidebar.');
          sidebar.classList.remove('md:w-16'); // Remove collapsed width
          sidebar.classList.add('md:w-64');    // Add expanded width
          mainContent.classList.remove('md:ml-16');
          mainContent.classList.add('md:ml-64');
          toggleSidebarDesktopButton.innerHTML = '<i class="mdi mdi-chevron-left text-xl"></i> <span class="ml-2">Collapse</span>';
          if (sidebarNavContent) sidebarNavContent.classList.remove('hidden');
          sidebar.classList.remove('sidebar-collapsed-hoverable'); // Remove hover indication class
        } else { // COLLAPSING
          console.log('[setDesktopSidebarVisible] Collapsing sidebar.');
          sidebar.classList.remove('md:w-64');  // Remove expanded width
          sidebar.classList.add('md:w-16');   // Add collapsed width (e.g., 4rem)
          mainContent.classList.remove('md:ml-64');
          mainContent.classList.add('md:ml-16'); // Adjust main content margin to collapsed width
          toggleSidebarDesktopButton.innerHTML = '<i class="mdi mdi-chevron-right text-xl"></i>'; // Icon only for collapsed state
          if (sidebarNavContent) sidebarNavContent.classList.add('hidden');
          sidebar.classList.add('sidebar-collapsed-hoverable'); // Add hover indication class
        }
        console.log('[setDesktopSidebarVisible] Calling adjustPinnedLogsLayout.');
        adjustPinnedLogsLayout(); // Adjust logs bar layout after sidebar change
      }

      // Mobile sidebar toggle
      mobileMenuButton.addEventListener('click', () => {
        sidebar.classList.remove('-translate-x-full');
        sidebar.classList.add('translate-x-0');
        // Optionally add an overlay for mobile
        // const overlay = document.createElement('div');
        // overlay.id = 'sidebar-overlay';
        // overlay.className = 'fixed inset-0 bg-black opacity-50 z-30 md:hidden';
        // document.body.appendChild(overlay);
        // overlay.addEventListener('click', () => toggleMobileSidebar(false));
      });

      closeSidebarButton.addEventListener('click', () => {
        sidebar.classList.add('-translate-x-full');
        sidebar.classList.remove('translate-x-0');
        // const overlay = document.getElementById('sidebar-overlay');
        // if (overlay) overlay remove();
      });

      // Desktop sidebar toggle
      toggleSidebarDesktopButton.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent click from bubbling to the parent sidebar element
        const isVisible = sidebar.classList.contains('md:w-64'); // Check if expanded
        console.log('[SidebarToggle] Button clicked. Currently isVisible (expanded):', isVisible);
        setDesktopSidebarVisible(!isVisible);
      });

      // Allow clicking the entire collapsed sidebar pane to expand it on desktop
      sidebar.addEventListener('click', () => {
        const isCollapsedDesktop = window.innerWidth >= 768 && sidebar.classList.contains('md:w-16');
        console.log('[SidebarClick] Sidebar area clicked. isCollapsedDesktop:', isCollapsedDesktop);
        if (isCollapsedDesktop) {
          setDesktopSidebarVisible(true);
        }
      });

      // Initialize sidebar state from localStorage for desktop
      const storedState = localStorage.getItem(desktopSidebarVisibleKey);
      if (storedState === 'false') {
        setDesktopSidebarVisible(false);
      } else { // null, 'true', or any other value defaults to visible
        setDesktopSidebarVisible(true);
      }
      // Explicitly call adjustPinnedLogsLayout after initial sidebar state is set
      console.log('[DOMContentLoaded] Initializing pinned logs layout.');
      adjustPinnedLogsLayout();

      // Close mobile sidebar when a nav link is clicked
      document.querySelectorAll('#sidebar .nav-link').forEach(link => {
        link.addEventListener('click', () => {
          if (window.innerWidth < 768) { // Tailwind's 'md' breakpoint
            sidebar.classList.add('-translate-x-full');
            sidebar.classList.remove('translate-x-0');
            // const overlay = document.getElementById('sidebar-overlay');
            // if (overlay) overlay remove();
          }
        });
      });

      // Set default view and initialize components
      document.addEventListener('DOMContentLoaded', () => {
        // Set "Home" as the default view
        document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
        const homeView = document.getElementById('home-view');
        const homeNavLink = document.querySelector('.nav-link[data-view="home"]');

        if (homeView) {
          homeView.classList.remove('hidden');
          document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
          if (homeNavLink) homeNavLink.classList.add('active-nav');
        } else {
          // Fallback if home-view is not found, show the first available view (e.g. lights)
          const lightsView = document.getElementById('lights-view');
          const lightsNavLink = document.querySelector('.nav-link[data-view="lights"]');
          if (lightsView) lightsView.classList.remove('hidden');
          if (lightsNavLink) lightsNavLink.classList.add('active-nav');
        }

        // Any other initializations that need to happen after DOM is ready
        // For example, if you still need to fetch initial data for other views:
        // fetchInitialDataForOtherViews();

        // THE REDUNDANT LISTENER BLOCK PREVIOUSLY HERE HAS BEEN REMOVED.

        // Setup interval to refresh CAN status periodically if desired
        // setInterval(fetchCanStatus, 30000); // Refresh every 30 seconds, for example
      });

      // Adjust logs layout on window resize (e.g., crossing mobile/desktop breakpoint)
      window.addEventListener('resize', adjustPinnedLogsLayout);

      const themeSwitcher = document.getElementById('themeSwitcher');
      const THEME_KEY = 'selectedTheme';
      const VALID_THEMES = ['default', 'dark', 'light', 'catppuccin-mocha', 'catppuccin-latte'];

      // Toast Notification Function
      function showToast(message, type = 'info', duration = 5000) {
        const container = document.getElementById('toast-container');
        if (!container) return;

        const toast = document.createElement('div');
        toast.className = `toast-message toast-${type}`;

        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        toast.appendChild(messageSpan);

        const closeButton = document.createElement('button');
        closeButton.className = 'toast-close-btn';
        closeButton.innerHTML = '&times;'; // MDI icon could be used here too e.g. <i class="mdi mdi-close"></i>
        closeButton.onclick = () => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300); // Remove after transition
        };
        toast.appendChild(closeButton);

        container.appendChild(toast);

        // Trigger the animation
        setTimeout(() => {
          toast.classList.add('show');
        }, 10); // Small delay to ensure transition is applied

        // Auto-remove toast
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300); // Remove from DOM after transition
        }, duration);
      }

      function applyTheme(theme) {
        let currentTheme = theme;
        if (typeof currentTheme !== 'string' || !VALID_THEMES.includes(currentTheme)) {
          console.warn(`Invalid theme value received: "${currentTheme}". Defaulting to 'default'.`);
          currentTheme = 'default';
        }

        document.body.classList.remove(...VALID_THEMES.map(t => `theme-${t}`));
        document.body.classList.add(`theme-${currentTheme}`);
        localStorage.setItem(THEME_KEY, currentTheme);

        if (themeSwitcher) {
          themeSwitcher.value = currentTheme;
        } else {
          // This case should ideally be caught by the check below before calling applyTheme initially
          // or before adding the event listener.
          console.warn('applyTheme called but themeSwitcher element not found when trying to set its value.');
        }
      }

      if (themeSwitcher) {
        themeSwitcher.addEventListener('change', (event) => {
          applyTheme(event.target.value);
        });

        // Load saved theme on page load
        const savedTheme = localStorage.getItem(THEME_KEY);
        // applyTheme will validate and default if savedTheme is null or invalid
        applyTheme(savedTheme);
      } else {
        console.error("Theme switcher element 'themeSwitcher' not found! Theme functionality will be impaired.");
        // Fallback to default theme if switcher is missing, so the page is at least styled consistently.
        // This call to applyTheme won't be able to set themeSwitcher.value, but will set body class and localStorage.
        applyTheme('default');
      }

      window.addEventListener('resize', adjustPinnedLogsLayout);

      // --- Add Event Listeners for Quick Light Controls ---
      document.addEventListener('DOMContentLoaded', () => {
        const quickControlButtons = [
          { id: 'btn-all-on', entityId: 'all_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-all-off', entityId: 'all_lights', command: 'set', data: { state: 'off' } },
          { id: 'btn-exterior-on', entityId: 'exterior_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-exterior-off', entityId: 'exterior_lights', command: 'set', data: { state: 'off' } },
          { id: 'btn-interior-on', entityId: 'interior_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-interior-off', entityId: 'interior_lights', command: 'set', data: { state: 'off' } },
        ];

        quickControlButtons.forEach(control => {
          const button = document.getElementById(control.id);
          if (button) {
            button.addEventListener('click', () => {
              // Temporarily disable button and show loading state
              const originalHtml = button.innerHTML;
              button.disabled = true;
              // Ensure the loading icon is an <i> tag if using MDI
              button.innerHTML = '<i class="mdi mdi-loading mdi-spin mr-2"></i>Processing...';

              callLightService(control.entityId, control.command, control.data)
                .then(response => {
                  // Assuming callLightService resolves with response data on success
                  // And responseData might have a message or status to show
                  let toastMessage = `${control.id.replace('btn-', '').replace('-', ' ')} command sent.`;
                  if (response && response.message) {
                    toastMessage = response.message;
                  } else if (response && response.status) {
                     toastMessage = `Status: ${response.status}`;
                  }
                  showToast(toastMessage, 'success');
                })
                .catch(error => {
                  // Error is already shown by showToast in callLightService,
                  // but we log it here for button-specific context if needed.
                  console.error(`Quick control for ${control.entityId} (button ${control.id}) failed:`, error);
                  // showToast is already called by callLightService on error.
                })
                .finally(() => {
                  button.disabled = false;
                  button.innerHTML = originalHtml;
                });
            });
          } else {
            console.warn(`Quick control button with ID ${control.id} not found.`);
          }
        });
      });
      // --- End of Added Event Listeners for Quick Light Controls ---

      // Initial data fetches
      fetchCanStatus(); // Existing
      fetchApiServerStatus(); // New
      fetchApplicationHealth(); // New

      // Setup periodic refresh for status sections (optional, adjust intervals as needed)
      setInterval(fetchCanStatus, 10000); // Refresh CAN status every 10 seconds
      setInterval(fetchApiServerStatus, 30000); // Refresh API status every 30 seconds
      setInterval(fetchApplicationHealth, 30000); // Refresh App health every 30 seconds

      // Theme switcher
        </script>
        <script src="https://cdn.tailwindcss.com"></script> <!-- Moved here -->
    </body>
</html>
