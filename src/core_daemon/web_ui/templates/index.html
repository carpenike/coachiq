<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rvc2api UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
  </head>
  <body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col">
    <header class="bg-gray-800 shadow p-4 text-xl font-semibold flex items-center justify-between">
      <span>rvc2api Dashboard</span>
    </header>

    <div class="flex flex-1 overflow-hidden">
      <!-- Sidebar Navigation -->
      <aside id="sidebar" class="w-64 bg-gray-800 p-4 space-y-4 border-r border-gray-700 transition-all duration-300 overflow-y-auto flex flex-col justify-between">
        <div>
          <div class="flex justify-between items-center mb-4">
            <span class="text-lg font-semibold">Navigation</span>
          </div>
          <nav class="space-y-2">
            <button data-view="lights" class="nav-link w-full text-left text-gray-300 hover:text-white">Lights</button>
            <button data-view="logs" class="nav-link w-full text-left text-gray-300 hover:text-white">Logs</button>
            
            <!-- Configuration Section -->
            <div class="pt-2"> 
              <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">
                Configuration Files
              </h3>
              <div class="space-y-1">
                <button data-view="mapping" class="nav-link w-full text-left text-gray-300 hover:text-white pl-4"> 
                  device_mapping.yml
                </button>
                <button data-view="spec" class="nav-link w-full text-left text-gray-300 hover:text-white pl-4"> 
                  rvc.json
                </button>
              </div>
            </div>
          </nav>
        </div>
        <div class="border-t border-gray-700 pt-4 text-center">
          <button id="toggleSidebar" class="text-gray-400 hover:text-gray-100">
            <i class="mdi mdi-chevron-left"></i> Collapse
          </button>
        </div>
      </aside>

      <!-- Main content area -->
      <main class="flex-1 overflow-y-auto p-6">
        <section id="lights-view" class="view-section">
          <div class="flex items-center justify-between mb-4">
            <h1 class="text-3xl font-bold">RV-C Lights</h1>
            <div>
              <label class="block mb-1 text-sm text-gray-300">
                <i class="mdi mdi-filter-variant mr-1"></i>Filter by Area:
              </label>
              <select id="area-filter" class="bg-gray-900 text-gray-100 border border-gray-700 rounded p-2">
                <option value="All">All</option>
              </select>
            </div>
          </div>
          <div id="light-grid" class="space-y-8">
            <p id="lights-loading-message">Loading lights...</p>
          </div>
        </section>

        <section id="logs-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Live Logs</h1>
          <div class="mb-4 flex flex-wrap gap-4">
            <select id="log-level" class="bg-gray-800 border border-gray-700 text-white rounded p-2">
              <option value="DEBUG">DEBUG</option>
              <option value="INFO" selected>INFO</option>
              <option value="WARNING">WARNING</option>
              <option value="ERROR">ERROR</option>
              <option value="CRITICAL">CRITICAL</option>
            </select>
            <input id="log-search" type="text" placeholder="Search logs..." class="bg-gray-800 border border-gray-700 text-white rounded p-2 flex-1" />
            <button id="log-pause" class="bg-gray-700 hover:bg-gray-600 text-white rounded p-2">Pause</button>
            <button id="log-resume" class="bg-gray-700 hover:bg-gray-600 text-white rounded p-2" disabled>Resume</button>
          </div>
          <pre id="log-stream" class="bg-black text-green-400 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
          <p id="logs-waiting-message" class="text-gray-500 hidden">Waiting for logs...</p>
        </section>

        <section id="mapping-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Current device_mapping.yml</h1>
          <pre id="mapping-content" class="bg-gray-800 text-green-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
        </section>

        <section id="spec-view" class="view-section hidden">
          <h1 class="text-3xl font-bold mb-6">Current rvc.json</h1>
          <pre id="spec-content" class="bg-gray-800 text-blue-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap"></pre>
        </section>
      </main>
    </div>

    <script>
      const socket = new WebSocket(`ws://${location.host}/ws`);
      const grid = document.getElementById('light-grid');
      const filter = document.getElementById('area-filter');
      const lightStates = {};
      const lightsLoadingMessage = document.getElementById('lights-loading-message');

      // WebSocket for entity updates
      const entitySocket = new WebSocket(`ws://${location.host}/ws`);

      entitySocket.onmessage = (event) => {
        const payload = JSON.parse(event.data);
        if (!payload.entity_id) return;
        // Merge new payload with existing state to preserve all fields
        lightStates[payload.entity_id] = { 
          ...(lightStates[payload.entity_id] || {}), 
          ...payload 
        };
        renderGroupedLights();
      };

      function getCardColor(brightness, isOn) {
        if (!isOn) return 'bg-gray-800';
        const alpha = brightness / 100;
        return `bg-[rgba(234,179,8,${alpha.toFixed(2)})] text-black`;
      }

      function renderCard(entity) {
        const { entity_id, state, value, raw, capabilities = [], friendly_name } = entity;
        const brightness = raw?.operating_status ?? 0;
        const brightnessUI = Math.round(brightness / 2);
        const isOn = state === 'on';
        const colorClass = getCardColor(brightnessUI, isOn);

        const card = document.createElement('div');
        card.className = `rounded-2xl p-4 shadow transition-colors duration-300 ${colorClass} relative group`;
        card.style.cursor = 'pointer';
        card.id = entity_id;
        card.innerHTML = `
          <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
            <i class="mdi mdi-power text-yellow-400"></i>
          </div>
          <h2 class="text-xl font-semibold mb-2">${friendly_name || entity_id}</h2>
          <p class="mb-2 flex items-center"><i class="mdi ${isOn ? 'mdi-lightbulb-on' : 'mdi-lightbulb-off'} mr-1"></i><strong>${state}</strong></p>
          <p class="mb-2 flex items-center"><i class="mdi mdi-brightness-6 mr-1"></i>${brightnessUI}%</p>
          ${capabilities.includes('brightness') ? `<input type="range" min="0" max="100" value="${brightnessUI}" class="w-full slider" />` : ''}
        `;

        card.addEventListener('click', (e) => {
          if (e.target.tagName === 'INPUT') return;
          fetch(`/entities/${entity_id}/control`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command: 'toggle' })
          });
        });

        const slider = card.querySelector('input');
        if (slider) {
          slider.addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            fetch(`/entities/${entity_id}/control`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ command: 'set', state: 'on', brightness: level })
            });
          });
        }

        return card;
      }

      function renderGroupedLights() {
        grid.innerHTML = '';
        const selected = filter.value;
        const grouped = {};

        for (const entity of Object.values(lightStates)) {
          if (entity.device_type !== 'light') { // Explicitly check if the entity is a light
            continue;
          }
          const area = entity?.suggested_area || 'Unknown';
          if (selected !== 'All' && selected !== area) continue;

          if (!grouped[area]) grouped[area] = [];
          grouped[area].push(entity);
        }

        for (const area of Object.keys(grouped).sort()) {
          const section = document.createElement('div');
          section.innerHTML = `
            <h2 class="text-2xl font-bold mb-1">${area}</h2>
            <div class="border-t border-gray-600 my-2"></div>
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"></div>
          `;
          const sectionGrid = section.querySelector('div.grid');

          grouped[area].forEach(entity => {
            sectionGrid.appendChild(renderCard(entity));
          });

          grid.appendChild(section);
        }
      }

      filter.addEventListener('change', renderGroupedLights);

      // WebSocket for logs - to be initialized when log view is active
      let logSocket = null;
      let isLogPaused = false;
      const logStream = document.getElementById('log-stream');
      const logLevelFilter = document.getElementById('log-level');
      const logSearchInput = document.getElementById('log-search');
      const logsWaitingMessage = document.getElementById('logs-waiting-message');

      function connectLogSocket() {
        if (logSocket && logSocket.readyState === WebSocket.OPEN) {
          return;
        }
        logSocket = new WebSocket(`ws://${location.host}/ws/logs`);
        logsWaitingMessage.classList.remove('hidden'); // Show waiting message

        logSocket.onopen = () => {
          console.log("Log WebSocket connected");
          logStream.innerHTML = ''; // Clear previous logs on new connection
          // logsWaitingMessage.classList.add('hidden'); // Hide if logs start coming immediately, or keep visible until first message
        };

        logSocket.onmessage = (event) => {
          if (isLogPaused) return;
          logsWaitingMessage.classList.add('hidden'); // Hide waiting message on first log

          const logEntry = event.data;
          const currentLogLevel = logLevelFilter.value.toUpperCase();
          const searchTerm = logSearchInput.value.toLowerCase();

          // Apply log level filter (assuming log format "TIMESTAMP LEVEL NAME: MESSAGE")
          // A more robust parsing might be needed if format varies significantly
          const levelMatch = logEntry.match(/\S+\s+(\w+)/);
          const entryLogLevel = levelMatch ? levelMatch[1].toUpperCase() : "UNKNOWN";
          
          const logLevels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"];
          const currentFilterIndex = logLevels.indexOf(currentLogLevel);
          const entryLevelIndex = logLevels.indexOf(entryLogLevel);

          if (entryLevelIndex < currentFilterIndex) {
            return; // Skip if entry level is lower than selected filter level
          }

          // Apply search term filter
          if (searchTerm && !logEntry.toLowerCase().includes(searchTerm)) {
            return; // Skip if search term not found
          }

          const logLine = document.createElement('div');
          logLine.textContent = logEntry;
          logStream.appendChild(logLine);
          logStream.scrollTop = logStream.scrollHeight; // Auto-scroll
        };

        logSocket.onerror = (error) => {
          console.error("Log WebSocket error:", error);
          logStream.innerHTML += '<div class="text-red-500">Log WebSocket error. See console for details.</div>';
        };

        logSocket.onclose = () => {
          console.log("Log WebSocket disconnected");
          // Optionally add a message to the UI, or attempt to reconnect
        };
      }

      function disconnectLogSocket() {
        if (logSocket) {
          logSocket.close();
          logSocket = null;
          console.log("Log WebSocket intentionally disconnected");
        }
      }

      // Log controls
      document.getElementById('log-pause').addEventListener('click', () => {
        isLogPaused = true;
        document.getElementById('log-pause').disabled = true;
        document.getElementById('log-resume').disabled = false;
      });

      document.getElementById('log-resume').addEventListener('click', () => {
        isLogPaused = false;
        document.getElementById('log-pause').disabled = false;
        document.getElementById('log-resume').disabled = true;
        logStream.scrollTop = logStream.scrollHeight; // Scroll to bottom on resume
      });
      
      // Re-apply filters when they change
      logLevelFilter.addEventListener('change', () => { 
        logStream.innerHTML = ''; // Clear and let new messages re-populate with new filter
      });
      logSearchInput.addEventListener('input', () => {
        logStream.innerHTML = ''; // Clear and let new messages re-populate with new filter
        // For immediate filtering of existing content (if not clearing), 
        // you'd need to re-evaluate all stored logs, which is more complex.
        // This approach filters new incoming logs.
        if (logSocket && logSocket.readyState === WebSocket.OPEN && logStream.childElementCount === 0) {
            logsWaitingMessage.classList.remove('hidden');
        }
      });


      fetch('/lights')
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          lightsLoadingMessage.classList.add('hidden');
          for (const entity of Object.values(data)) {
            lightStates[entity.entity_id] = entity;
          }

          const areas = new Set(Object.values(lightStates).map(e => e?.suggested_area || 'Unknown'));
          for (const area of [...areas].sort()) {
            const opt = document.createElement('option');
            opt.value = area;
            opt.textContent = area;
            filter.appendChild(opt);
          }

          renderGroupedLights();
        })
        .catch(error => {
          console.error("Failed to fetch lights:", error);
          lightsLoadingMessage.textContent = 'Error loading lights. Please check console.';
          lightsLoadingMessage.classList.remove('hidden');
          lightsLoadingMessage.classList.add('text-red-500');
        });

      document.querySelectorAll('.nav-link').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.getAttribute('data-view');
          document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
          document.getElementById(`${view}-view`).classList.remove('hidden');

          if (view === 'logs') {
            connectLogSocket();
            document.getElementById('log-resume').click(); // Start unpaused
            if (logStream.childElementCount === 0) { // Check if logs view is empty
                logsWaitingMessage.classList.remove('hidden');
            }
          } else {
            disconnectLogSocket();
            logsWaitingMessage.classList.add('hidden'); // Hide waiting message when leaving logs view
          }

          if (view === 'mapping') {
            fetch('/static/device_mapping.yml')
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('mapping-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch device_mapping.yml:", err);
                document.getElementById('mapping-content').textContent = `Error: Could not load device_mapping.yml.\n${err.message}`;
              });
          } else if (view === 'spec') {
            fetch('/static/rvc.json')
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('spec-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json:", err);
                document.getElementById('spec-content').textContent = `Error: Could not load rvc.json.\n${err.message}`;
              });
          }
        });
      });

      document.getElementById('toggleSidebar').addEventListener('click', () => {
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.toggle('w-64');
        sidebar.classList.toggle('w-0');
        sidebar.classList.toggle('p-4');
        const icon = document.querySelector('#toggleSidebar i');
        icon.classList.toggle('mdi-chevron-left');
        icon.classList.toggle('mdi-chevron-right');
        document.getElementById('toggleSidebar').innerHTML = sidebar.classList.contains('w-0')
          ? '<i class="mdi mdi-chevron-right"></i> Expand'
          : '<i class="mdi mdi-chevron-left"></i> Collapse';
      });
    </script>
  </body>
</html>
