<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>rvc2api UI</title>
        <script src="https://cdn.tailwindcss.com" defer></script> <!-- Moved here and deferred -->
        <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css"
              rel="stylesheet">
        <link rel="stylesheet"
              href="{{ url_for('static', path='css/custom.css') }}">
    </head>
    <body class="theme-default bg-gray-900 text-gray-100 min-h-screen flex flex-col antialiased">
        <div id="toast-container" role="status" aria-live="polite"></div>
        <!-- Added ARIA roles -->
        <!-- Toast messages will appear here -->
        <header class="bg-gray-800 shadow p-4 text-xl font-semibold flex items-center justify-between sticky top-0 z-50">
            <div class="flex items-center">
                <button id="mobileMenuButton"
                        class="md:hidden text-gray-300 hover:text-white mr-4">
                    <i class="mdi mdi-menu text-2xl" aria-hidden="true"></i>
                </button>
                <span>rvc2api Dashboard</span>
            </div>
            <div class="relative">
                <select id="themeSwitcher"
                        class="bg-gray-700 text-gray-200 text-sm rounded-md p-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="default">Default Theme</option>
                    <option value="dark">Dark Theme</option>
                    <option value="light">Light Theme</option>
                    <option value="catppuccin-mocha">Catppuccin Mocha</option>
                    <option value="catppuccin-latte">Catppuccin Latte</option>
                    <!-- Add more themes here -->
                </select>
            </div>
        </header>
        <div class="flex flex-1 overflow-hidden">
            <!-- Sidebar Navigation -->
            <aside id="sidebar"
                   class="fixed inset-y-0 left-0 z-40 transform -translate-x-full mt-16 md:mt-0 md:fixed md:left-0 md:top-16 md:h-[calc(100vh-4rem)] md:transform-none md:w-64 bg-gray-800 p-4 border-r border-gray-700 transition-all duration-300 ease-in-out flex flex-col justify-between">
                <div id="sidebarNavContent" class="flex-grow overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <span class="text-lg font-semibold">Navigation</span>
                        <button id="closeSidebarButton"
                                class="md:hidden text-gray-400 hover:text-white">
                            <i class="mdi mdi-close text-2xl" aria-hidden="true"></i>
                        </button>
                    </div>
                    <nav class="space-y-2">
                        <button data-view="home"
                                class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700 active-nav">
                            <i class="mdi mdi-home-outline mr-2" aria-hidden="true"></i>Home
                        </button>
                        <button data-view="lights"
                                class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                            <i class="mdi mdi-lightbulb-outline mr-2" aria-hidden="true"></i>Lights
                        </button>
                        <!-- Removed Logs button from main navigation, will be controlled by pinned bar -->
                        <!-- Configuration Section -->
                        <div class="pt-2">
                            <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">Configuration Files</h3>
                            <div class="space-y-1">
                                <button data-view="mapping"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    <i class="mdi mdi-file-settings-outline mr-2" aria-hidden="true"></i>device_mapping.yml
                                </button>
                                <button data-view="spec"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    <i class="mdi mdi-code-json mr-2" aria-hidden="true"></i>rvc.json
                                </button>
                            </div>
                        </div>
                        <!-- Unmapped Entries Link -->
                        <div class="pt-2">
                            <h3 class="px-2 py-1 text-xs uppercase text-gray-500 font-semibold tracking-wider">Troubleshooting</h3>
                            <div class="space-y-1">
                                <button data-view="unmapped"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    <i class="mdi mdi-alert-circle-outline mr-2" aria-hidden="true"></i>Unmapped Entries
                                </button>
                                <button data-view="unknown-pgns"
                                        class="nav-link w-full text-left px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">
                                    <i class="mdi mdi-help-rhombus-outline mr-2" aria-hidden="true"></i>Unknown PGNs
                                </button>
                            </div>
                        </div>
                    </nav>
                </div>
                <div class="border-t border-gray-700 pt-4 text-center">
                    <button id="toggleSidebarDesktop"
                            class="text-gray-400 hover:text-gray-100 w-full flex items-center justify-center p-2 rounded hover:bg-gray-700">
                        <i class="mdi mdi-chevron-left text-xl" aria-hidden="true"></i> <span class="ml-2">Collapse</span>
                    </button>
                </div>
            </aside>
            <!-- Main content area -->
            <main id="mainContent"
                  class="flex-1 overflow-y-auto p-6 transition-all duration-300 ease-in-out md:ml-64">
                <!-- Removed md:h-[calc(100vh-4rem)] -->
                <!-- Home View / Dashboard -->
                <section id="home-view" class="view-section">
                    <h1 class="text-3xl font-bold mb-8 text-gray-100">Dashboard</h1>
                    <div class="mb-10">
                        <h2 class="text-2xl font-semibold mb-4 text-gray-300">Quick Light Controls</h2>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-4">
                            <!-- Column 1: All Lights -->
                            <div class="space-y-4">
                                <button id="btn-all-on"
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-lightbulb-group-outline mr-2" aria-hidden="true"></i>All Lights On
                                </button>
                                <button id="btn-all-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-lightbulb-group-off-outline mr-2" aria-hidden="true"></i>All Lights Off
                                </button>
                            </div>
                            <!-- Column 2: Exterior Lights -->
                            <div class="space-y-4">
                                <button id="btn-exterior-on"
                                        class="w-full bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-outdoor-lamp mr-2" aria-hidden="true"></i>Exterior On
                                </button>
                                <button id="btn-exterior-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-dome-light mr-2" aria-hidden="true"></i>Exterior Off
                                </button>
                            </div>
                            <!-- Column 3: Interior Lights -->
                            <div class="space-y-4">
                                <button id="btn-interior-on"
                                        class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-home-lightbulb-outline mr-2" aria-hidden="true"></i>Interior On
                                </button>
                                <button id="btn-interior-off"
                                        class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg shadow hover:shadow-md transition-transform transform hover:scale-105 flex items-center justify-center">
                                    <i class="mdi mdi-home-lightbulb-off-outline mr-2" aria-hidden="true"></i>Interior Off
                                </button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h2 class="text-2xl font-semibold mb-4 text-gray-300">Scenes</h2>
                        <div class="bg-gray-800 p-6 rounded-lg shadow">
                            <p class="text-gray-400 mb-4">Scene management and definition coming soon.</p>
                            <p class="text-gray-500 text-sm mt-2 mb-4">
                                This section will allow you to define and trigger custom scenes involving multiple devices (lights, locks, etc.).
                            </p>
                            <button id="btn-create-scene"
                                    class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-blue-600">
                                <i class="mdi mdi-plus-circle-outline mr-2" aria-hidden="true"></i>Create New Scene
                            </button>
                        </div>
                    </div>
                    <!-- CAN Bus Status Section -->
                    <div class="mt-10">
                        <h2 class="text-2xl font-semibold mb-6 text-gray-300">System Status</h2>
                        <!-- API Server Status -->
                        <div class="mb-6">
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">API Server</h3>
                            <div id="api-status-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="api-status-loading-message" class="text-gray-400">Loading API server status...</p>
                                <!-- API server status will be loaded here by JavaScript -->
                            </div>
                        </div>
                        <!-- Application Health -->
                        <div class="mb-6">
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">Application Health</h3>
                            <div id="app-health-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="app-health-loading-message" class="text-gray-400">Loading application health...</p>
                                <!-- Application health details (e.g., config load status, connected clients) will be loaded here -->
                            </div>
                        </div>
                        <!-- CAN Bus Status Sub-section -->
                        <div>
                            <h3 class="text-xl font-semibold mb-3 text-gray-200">CAN Bus Interfaces</h3>
                            <div id="can-status-container" class="bg-gray-800 p-6 rounded-lg shadow">
                                <p id="can-status-loading-message" class="text-gray-400">Loading CAN status...</p>
                                <!-- CAN status will be loaded here by JavaScript -->
                            </div>
                        </div>
                    </div>
                </section>
                <section id="lights-view" class="view-section hidden">
                    <div class="flex items-center justify-between mb-4">
                        <h1 class="text-3xl font-bold">RV-C Lights</h1>
                        <div>
                            <label class="block mb-1 text-sm text-gray-300">
                                <i class="mdi mdi-filter-variant mr-1" aria-hidden="true"></i>Filter by Area:
                            </label>
                            <select id="area-filter"
                                    class="bg-gray-900 text-gray-100 border border-gray-700 rounded p-2">
                                <option value="All">All</option>
                            </select>
                        </div>
                    </div>
                    <div id="light-grid" class="space-y-8">
                        <p id="lights-loading-message">Loading lights...</p>
                    </div>
                </section>
                <section id="mapping-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Current device_mapping.yml</h1>
                    <pre id="mapping-content"
                         class="bg-gray-800 text-green-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap">Loading device_mapping.yml...</pre>
                </section>
                <section id="spec-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-2">Current rvc.json</h1>
                    <div id="spec-metadata" class="mb-4 text-sm text-gray-400">Loading spec metadata...</div>
                    <pre id="spec-content"
                         class="bg-gray-800 text-blue-300 p-4 rounded overflow-auto max-h-[70vh] font-mono text-sm whitespace-pre-wrap">Loading rvc.json...</pre>
                </section>
                <!-- Unmapped Entries View -->
                <section id="unmapped-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Unmapped CAN Bus Entries</h1>
                    <p class="mb-4 text-gray-400">
                        These are CAN messages received by the system that could not be mapped to a known device based on your
                        <code>device_mapping.yml</code>. Use this information to help build out your configuration.
                    </p>
                    <div id="unmapped-entries-container" class="space-y-6">
                        <p id="unmapped-loading-message">Loading unmapped entries...</p>
                        <!-- Unmapped entries will be loaded here -->
                    </div>
                </section>
                <!-- Unknown PGNs View -->
                <section id="unknown-pgns-view" class="view-section hidden">
                    <h1 class="text-3xl font-bold mb-6">Unknown PGNs (Not in rvc.json)</h1>
                    <p class="mb-4 text-gray-400">
                        These are CAN messages received by the system where the PGN (extracted from the arbitration ID)
                        was <strong>not found</strong> in your <code>rvc.json</code> specification file. This means the system
                        does not know how to interpret these messages at a fundamental PGN level.
                    </p>
                    <div id="unknown-pgns-container" class="space-y-6">
                        <p id="unknown-pgns-loading-message">Loading unknown PGNs...</p>
                        <!-- Unknown PGNs will be loaded here -->
                    </div>
                </section>
            </main>
        </div>
        <!-- Pinned Logs Container -->
        <div id="pinnedLogsContainer"
             class="fixed bottom-0 left-0 right-0 z-[60] bg-gray-800 border-t border-gray-700 shadow-lg transition-all duration-300 ease-in-out"
             style="height: 3rem">
            <!-- Initial height for collapsed header -->
            <div id="pinnedLogsResizeHandle"
                 class="absolute top-0 left-0 right-0 h-2 cursor-ns-resize"
                 style="z-index: 61"></div>
            <!-- Draggable Resize Handle -->
            <div id="pinnedLogsHeader"
                 class="flex justify-between items-center p-2 h-12 cursor-pointer hover:bg-gray-700">
                <span class="font-semibold text-gray-300 ml-2">Logs</span>
                <button id="togglePinnedLogsBtn" class="text-gray-300 hover:text-white p-1">
                    <i class="mdi mdi-chevron-up text-2xl" aria-hidden="true"></i>
                </button>
            </div>
            <div id="pinnedLogsContent"
                 class="hidden bg-gray-800 px-4 pb-4 pt-2 flex flex-col"
                 style="height: calc(30vh - 3rem)">
                <!-- Removed max-height: 400px -->
                <div class="flex flex-wrap gap-x-4 gap-y-2 mb-3 items-center">
                    <select id="log-level"
                            class="bg-gray-700 border border-gray-600 text-white rounded p-1.5 text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="DEBUG">DEBUG</option>
                        <option value="INFO" selected>INFO</option>
                        <option value="WARNING">WARNING</option>
                        <option value="ERROR">ERROR</option>
                        <option value="CRITICAL">CRITICAL</option>
                    </select>
                    <input id="log-search"
                           type="text"
                           placeholder="Search logs..."
                           class="bg-gray-700 border border-gray-600 text-white rounded p-1.5 text-sm flex-grow min-w-[200px] focus:ring-blue-500 focus:border-blue-500" />
                    <div class="flex gap-2">
                        <button id="log-pause"
                                class="bg-gray-600 hover:bg-gray-500 text-white rounded px-3 py-1.5 text-sm">
                            Pause
                        </button>
                        <button id="log-resume"
                                class="bg-gray-500 hover:bg-gray-400 text-white rounded px-3 py-1.5 text-sm"
                                disabled>Resume</button>
                        <button id="log-clear"
                                class="bg-red-600 hover:bg-red-500 text-white rounded px-3 py-1.5 text-sm">
                            Clear
                        </button>
                        <!-- Added Clear button -->
                    </div>
                </div>
                <pre id="log-stream"
                     class="bg-black text-green-400 p-3 rounded overflow-auto flex-1 min-h-0 font-mono text-xs whitespace-pre-wrap"></pre> <!-- Removed h-full, added flex-1 min-h-0 -->
                <p id="logs-waiting-message"
                   class="text-gray-500 hidden absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
                    Waiting for logs...
                </p>
            </div>
        </div>
        <script>
    (function() { // START IIFE
      // const socket = new WebSocket(`ws://${location.host}/ws`); // This line will be removed
      const grid = document.getElementById('light-grid');
      const filter = document.getElementById('area-filter');
      const lightStates = {};
      const lightsLoadingMessage = document.getElementById('lights-loading-message');
      const apiBasePath = '/api'; // Define base path for API calls

      // CAN Status Elements
      const canStatusContainer = document.getElementById('can-status-container');
      const canStatusLoadingMessage = document.getElementById('can-status-loading-message');

      // API Server Status Elements (New)
      const apiStatusContainer = document.getElementById('api-status-container');
      const apiStatusLoadingMessage = document.getElementById('api-status-loading-message');

      // Application Health Elements (New)
      const appHealthContainer = document.getElementById('app-health-container');
      const appHealthLoadingMessage = document.getElementById('app-health-loading-message');

      // Pinned Logs Elements
      const pinnedLogsContainer = document.getElementById('pinnedLogsContainer');
      const pinnedLogsHeader = document.getElementById('pinnedLogsHeader');
      const togglePinnedLogsBtn = document.getElementById('togglePinnedLogsBtn');
      const pinnedLogsChevronIcon = togglePinnedLogsBtn.querySelector('i');
      const pinnedLogsContent = document.getElementById('pinnedLogsContent');
      const mainContent = document.getElementById('mainContent'); // Already defined, ensure it is

      // Log stream elements (now part of pinnedLogsContent)
      let logSocket = null;
      let isLogPaused = false;
      const logStream = document.getElementById('log-stream');
      const logLevelFilter = document.getElementById('log-level');
      const logSearchInput = document.getElementById('log-search');
      const logsWaitingMessage = document.getElementById('logs-waiting-message');
      const logPauseBtn = document.getElementById('log-pause');
      const logResumeBtn = document.getElementById('log-resume');
      const logClearBtn = document.getElementById('log-clear'); // Get clear button

      const PINNED_LOGS_OPEN_KEY = 'pinnedLogsOpen';
      const PINNED_LOGS_HEIGHT_KEY = 'pinnedLogsHeight';
      const COLLAPSED_LOGS_HEIGHT = '3rem'; // Height of the header bar
      const DEFAULT_EXPANDED_LOGS_HEIGHT_VH = 30; // Default expanded height in vh
      const MIN_LOGS_PANEL_HEIGHT_PX = 80; // Minimum height in pixels (e.g., header + a bit of content)
      const MAX_LOGS_PANEL_HEIGHT_VH_PERCENT = 80; // Max height as % of viewport height
      let currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`; // Store as string like '30vh'
      let isResizingLogs = false;
      let resizeRafId = null; // For requestAnimationFrame
      let pendingResizeHeightPx = 0; // To store height for RAF update
      let originalContainerTransition = ''; // To store original transition style

      // --- START: Log WebSocket Connection Functions ---
      const LOG_LEVELS = {
        DEBUG: 0,
        INFO: 1,
        WARNING: 2,
        ERROR: 3,
        CRITICAL: 4
      };

      function connectLogSocket() {
        if (logSocket && (logSocket.readyState === WebSocket.OPEN || logSocket.readyState === WebSocket.CONNECTING)) {
          console.log('[connectLogSocket] WebSocket already open or connecting.');
          return;
        }

        const logWebSocketUrl = `ws://${location.host}${apiBasePath}/ws/logs`;
        console.log(`[connectLogSocket] Connecting to log WebSocket: ${logWebSocketUrl}`);
        logSocket = new WebSocket(logWebSocketUrl);

        logSocket.onopen = () => {
          console.log('[connectLogSocket] Log WebSocket connected.');
          logsWaitingMessage.classList.add('hidden');
          logPauseBtn.disabled = false;
          logResumeBtn.disabled = true; // Resume is disabled when connected and not paused
          isLogPaused = false; // Reset pause state on new connection
        };

        logSocket.onmessage = (event) => {
          if (isLogPaused) return;

          let logEntry;
          try {
            logEntry = JSON.parse(event.data);
          } catch (e) {
            console.warn('[connectLogSocket] Received non-JSON log message:', event.data);
            // Fallback for plain text logs if necessary, though JSON is expected for filtering
            logEntry = { level: 'INFO', message: event.data, timestamp: new Date().toISOString() };
          }

          const currentLogLevel = LOG_LEVELS[logLevelFilter.value.toUpperCase()] || 0;
          const messageLogLevel = LOG_LEVELS[logEntry.level.toUpperCase()] === undefined ? LOG_LEVELS.INFO : LOG_LEVELS[logEntry.level.toUpperCase()];

          if (messageLogLevel < currentLogLevel) {
            return; // Skip if message level is below selected filter level
          }

          const searchTerm = logSearchInput.value.toLowerCase();
          // Ensure logEntry.message is a string before calling toLowerCase()
          const messageText = String(logEntry.message || '').toLowerCase();

          if (searchTerm && !messageText.includes(searchTerm)) {
            return; // Skip if search term is present and not found in message
          }

          const logLine = document.createElement('div');
          // Basic styling, can be enhanced with colors per level
          logLine.textContent = `[${logEntry.timestamp || new Date().toISOString()}] [${logEntry.level || 'INFO'}] ${logEntry.message}`;
          logStream.appendChild(logLine);

          // Auto-scroll to bottom
          logStream.scrollTop = logStream.scrollHeight;
        };

        logSocket.onerror = (error) => {
          console.error('[connectLogSocket] Log WebSocket error:', error);
          showToast('Log connection error.', 'error');
          logsWaitingMessage.textContent = 'Log connection error. Retrying...';
          logsWaitingMessage.classList.remove('hidden');
        };

        logSocket.onclose = () => {
          console.log('[connectLogSocket] Log WebSocket disconnected.');
          logSocket = null;
          if (!pinnedLogsContent.classList.contains('hidden')) { // Only show if panel is open
            logsWaitingMessage.textContent = 'Log connection closed. Will attempt to reconnect if panel is open.';
            logsWaitingMessage.classList.remove('hidden');
            // Optional: implement a retry mechanism with backoff
            setTimeout(connectLogSocket, 5000); // Retry connection after 5 seconds
          }
          logPauseBtn.disabled = true;
          logResumeBtn.disabled = true;
        };
      }

      function disconnectLogSocket() {
        if (logSocket) {
          console.log('[disconnectLogSocket] Closing Log WebSocket.');
          logSocket.close();
          logSocket = null;
        }
        logsWaitingMessage.classList.add('hidden'); // Hide message when explicitly disconnecting
        logPauseBtn.disabled = true;
        logResumeBtn.disabled = true;
      }
      // --- END: Log WebSocket Connection Functions ---

      // --- START: Toast Notification System ---
      function createToastContainer() { // Defined before showToast
        let container = document.getElementById('toast-container');
        if (!container) {
          container = document.createElement('div');
          container.id = 'toast-container';
          // Ensure it has ARIA roles if created dynamically, though it's in HTML now
          container.setAttribute('role', 'status');
          container.setAttribute('aria-live', 'polite');
          container.className = 'fixed bottom-5 right-5 space-y-2 z-[100]'; // Ensure high z-index
          document.body.appendChild(container);
        }
        return container;
      }

      function showToast(message, type = 'info', duration = 3000) { // Single definition
        const toastContainer = document.getElementById('toast-container') || createToastContainer();
        const toast = document.createElement('div');
        toast.className = `p-4 rounded-md shadow-lg text-white max-w-sm`; // Added max-w-sm

        if (type === 'error') {
          toast.classList.add('bg-red-600');
        } else if (type === 'success') {
          toast.classList.add('bg-green-600');
        } else { // info or default
          toast.classList.add('bg-blue-600');
        }

        toast.textContent = message;
        toastContainer.appendChild(toast);

        // Fade out and remove
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transition = 'opacity 0.5s ease-out';
          setTimeout(() => {
            toast.remove();
            if (toastContainer.childElementCount === 0 && toastContainer.parentElement === document.body) {
              // Optionally remove container if it was dynamically added and is now empty
              // For now, keep it if it's defined in HTML.
            }
          }, 500);
        }, duration);
      }
      // --- END: Toast Notification System ---

      // Constants for sidebar widths
      const SIDEBAR_EXPANDED_WIDTH_DESKTOP = '16rem'; // Corresponds to md:w-64
      const SIDEBAR_COLLAPSED_WIDTH_DESKTOP = '4rem';  // Corresponds to md:w-16

      function adjustPinnedLogsLayout() {
        if (!pinnedLogsContainer || !sidebar) return;

        if (window.innerWidth < 768) { // Tailwind 'md' breakpoint (768px)
          // On mobile, sidebar is an overlay or hidden. Logs bar spans full width.
          pinnedLogsContainer.style.left = '0px';
        } else {
          // Desktop view: sidebar is fixed on the left
          const isSidebarCollapsedDesktop = sidebar.classList.contains('md:w-16');
          if (isSidebarCollapsedDesktop) {
            pinnedLogsContainer.style.left = SIDEBAR_COLLAPSED_WIDTH_DESKTOP;
          } else { // Sidebar is expanded (should have md:w-64)
            pinnedLogsContainer.style.left = SIDEBAR_EXPANDED_WIDTH_DESKTOP;
          }
        }
      }

      function setPinnedLogsState(isOpen, height) {
        console.log('[setPinnedLogsState] Called with isOpen:', isOpen, 'Height:', height);
        localStorage.setItem(PINNED_LOGS_OPEN_KEY, isOpen);
        if (isOpen && height) {
          localStorage.setItem(PINNED_LOGS_HEIGHT_KEY, height);
          currentExpandedLogsHeight = height;
        }

        if (isOpen) {
          console.log('[setPinnedLogsState] Opening pinned logs.');
          pinnedLogsContent.classList.remove('hidden');
          pinnedLogsContainer.style.height = currentExpandedLogsHeight;
          pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
          mainContent.style.paddingBottom = currentExpandedLogsHeight;
          pinnedLogsChevronIcon.classList.remove('mdi-chevron-up');
          pinnedLogsChevronIcon.classList.add('mdi-chevron-down');
          console.log('[setPinnedLogsState] Calling connectLogSocket.');
          connectLogSocket();
          if (logStream.childElementCount === 0 && logSocket && logSocket.readyState === WebSocket.OPEN) {
            console.log('[setPinnedLogsState] Showing logsWaitingMessage.');
            logsWaitingMessage.classList.remove('hidden');
          } else {
            // Ensure it's hidden if conditions aren't met or logs are present
            console.log('[setPinnedLogsState] Hiding logsWaitingMessage (or keeping hidden).');
            logsWaitingMessage.classList.add('hidden');
          }
        } else {
          console.log('[setPinnedLogsState] Closing pinned logs.');
          pinnedLogsContent.classList.add('hidden');
          pinnedLogsContainer.style.height = COLLAPSED_LOGS_HEIGHT;
          mainContent.style.paddingBottom = COLLAPSED_LOGS_HEIGHT; // Adjust padding for collapsed bar
          pinnedLogsChevronIcon.classList.remove('mdi-chevron-down');
          pinnedLogsChevronIcon.classList.add('mdi-chevron-up');
          // Consider disconnecting log socket if not needed by any other view,
          // but for a pinned pane, usually keep it connected if user might reopen.
          // For now, let's keep it simple and not disconnect immediately on collapse.
          // disconnectLogSocket(); // Optional: if you want to save resources
          console.log('[setPinnedLogsState] Hiding logsWaitingMessage because panel is closing.');
          logsWaitingMessage.classList.add('hidden');
        }
      }

      togglePinnedLogsBtn.addEventListener('click', () => {
        const isOpen = !pinnedLogsContent.classList.contains('hidden');
        setPinnedLogsState(!isOpen, currentExpandedLogsHeight);
      });
      pinnedLogsHeader.addEventListener('click', (e) => {
        if (e.target === pinnedLogsHeader || e.target === pinnedLogsHeader.querySelector('span')) {
            const isOpen = !pinnedLogsContent.classList.contains('hidden');
            setPinnedLogsState(!isOpen, currentExpandedLogsHeight);
        }
      });

      // Initialize pinned logs state from localStorage
      const savedIsOpen = localStorage.getItem(PINNED_LOGS_OPEN_KEY) === 'true';
      const savedHeight = localStorage.getItem(PINNED_LOGS_HEIGHT_KEY);
      if (savedHeight) {
        // Validate saved height against min/max before applying
        let heightNum = parseFloat(savedHeight);
        const unit = savedHeight.replace(/[\d.-]/g, '');
        if (unit === 'px') {
            heightNum = Math.max(MIN_LOGS_PANEL_HEIGHT_PX, Math.min(heightNum, window.innerHeight * (MAX_LOGS_PANEL_HEIGHT_VH_PERCENT / 100)));
            currentExpandedLogsHeight = `${heightNum}px`;
        } else if (unit === 'vh') {
            heightNum = Math.max((MIN_LOGS_PANEL_HEIGHT_PX / window.innerHeight) * 100, Math.min(heightNum, MAX_LOGS_PANEL_HEIGHT_VH_PERCENT));
            currentExpandedLogsHeight = `${heightNum}vh`;
        } else {
            // default to vh if unit is unknown or invalid
            currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`;
        }
      } else {
        currentExpandedLogsHeight = `${DEFAULT_EXPANDED_LOGS_HEIGHT_VH}vh`;
      }
      // Set initial state without animation for page load
      const originalTransition = pinnedLogsContainer.style.transition;
      pinnedLogsContainer.style.transition = 'none';
      setPinnedLogsState(savedIsOpen, currentExpandedLogsHeight);
      // Restore transition after initial setup
      // Use a timeout to ensure the no-transition style is applied before restoring it
      setTimeout(() => {
        pinnedLogsContainer.style.transition = originalTransition || 'height 0.3s ease-in-out';
      }, 50);

      // Pinned Logs Resizing Logic
      const pinnedLogsResizeHandle = document.getElementById('pinnedLogsResizeHandle');

      function applyResizeStyles() {
        if (!isResizingLogs) return; // Check if still resizing

        currentExpandedLogsHeight = `${pendingResizeHeightPx}px`;
        pinnedLogsContainer.style.height = currentExpandedLogsHeight;
        pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
        mainContent.style.paddingBottom = currentExpandedLogsHeight;

        resizeRafId = null; // Reset RAF ID
      }

      pinnedLogsResizeHandle.addEventListener('mousedown', (e) => {
        if (!pinnedLogsContent.classList.contains('hidden')) { // Only allow resize if panel is open
          e.preventDefault(); // Prevent text selection or other default actions
          isResizingLogs = true;
          const startY = e.clientY;
          const startHeight = pinnedLogsContainer.offsetHeight; // Get height in pixels

          originalContainerTransition = pinnedLogsContainer.style.transition;
          pinnedLogsContainer.style.transition = 'none'; // Disable transitions during drag

          document.body.style.userSelect = 'none';
          document.body.style.cursor = 'ns-resize';

          const onMouseMove = (moveEvent) => {
            if (!isResizingLogs) return;
            const dy = startY - moveEvent.clientY;
            let newHeightPx = startHeight + dy;

            const maxHeightPx = window.innerHeight * (MAX_LOGS_PANEL_HEIGHT_VH_PERCENT / 100);
            newHeightPx = Math.max(MIN_LOGS_PANEL_HEIGHT_PX, Math.min(newHeightPx, maxHeightPx));

            pendingResizeHeightPx = newHeightPx;

            if (resizeRafId === null) {
              resizeRafId = requestAnimationFrame(applyResizeStyles);
            }
          };

          const onMouseUp = () => {
            if (isResizingLogs) {
              isResizingLogs = false;
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);

              if (resizeRafId !== null) {
                cancelAnimationFrame(resizeRafId);
                resizeRafId = null;
              }

              // Apply the final height directly to ensure it's set before saving
              // This uses the last value of pendingResizeHeightPx calculated in onMouseMove
              currentExpandedLogsHeight = `${pendingResizeHeightPx}px`;
              pinnedLogsContainer.style.height = currentExpandedLogsHeight;
              pinnedLogsContent.style.height = `calc(${currentExpandedLogsHeight} - ${COLLAPSED_LOGS_HEIGHT})`;
              mainContent.style.paddingBottom = currentExpandedLogsHeight;

              localStorage.setItem(PINNED_LOGS_HEIGHT_KEY, currentExpandedLogsHeight);

              document.body.style.userSelect = '';
              document.body.style.cursor = '';
              pinnedLogsContainer.style.transition = originalContainerTransition || 'height 0.3s ease-in-out'; // Restore transitions
            }
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
      });

      // WebSocket for entity updates
      const entitySocket = new WebSocket(`ws://${location.host}${apiBasePath}/ws`);

      // --- Fetch and Display CAN Status ---
      async function fetchCanStatus() {
        try {
          const response = await fetch(`${apiBasePath}/can/status`);
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          const statusData = await response.json();
          updateCanStatusView(statusData);
        } catch (error) {
          console.error("Failed to fetch CAN status:", error);
          if (canStatusContainer && canStatusLoadingMessage) {
            canStatusLoadingMessage.textContent = 'Failed to load CAN status.';
            canStatusLoadingMessage.classList.remove('hidden');
          } else if (canStatusContainer) {
            canStatusContainer.innerHTML = '<p class="text-red-400">Failed to load CAN status.</p>';
          }
        }
      }

      function updateCanStatusView(statusData) {
        if (!canStatusContainer) return;

        canStatusLoadingMessage.classList.add('hidden'); // Hide loading message
        canStatusContainer.innerHTML = ''; // Clear previous content or loading message

        if (Object.keys(statusData).length === 0) {
          const p = document.createElement('p');
          p.className = 'text-gray-400';
          p.textContent = 'No CAN interfaces found or status not available.';
          canStatusContainer.appendChild(p);
          return;
        }

        const ul = document.createElement('ul');
        ul.className = 'space-y-6'; // Increased spacing between interface cards

        for (const interfaceName in statusData) {
          const iface = statusData[interfaceName];
          const li = document.createElement('li');
          li.className = 'p-5 bg-gray-700 rounded-lg shadow-md'; // Slightly more padding and shadow

          // Interface Name Header
          const h3 = document.createElement('h3');
          h3.className = 'text-xl font-semibold text-blue-300 mb-4 border-b border-gray-600 pb-2';
          h3.textContent = interfaceName;
          li.appendChild(h3);

          const mainGridDiv = document.createElement('div');
          mainGridDiv.className = 'grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2 text-sm';

          // Left Column (State, Bitrate, etc.)
          const leftColDiv = document.createElement('div');
          let statusText = iface.state || 'N/A';
          let statusColor = 'text-gray-400'; // Default/unknown
          if (iface.state === 'ERROR-ACTIVE' || iface.state === 'UP' || iface.state === 'RUNNING') statusColor = 'text-green-400';
          else if (iface.state === 'ERROR-WARNING') statusColor = 'text-yellow-400';
          else if (iface.state === 'ERROR-PASSIVE') statusColor = 'text-orange-500';
          else if (iface.state === 'BUS-OFF' || iface.state === 'DOWN' || iface.state === 'STOPPED') statusColor = 'text-red-500';

          const bitrateDisplay = iface.bitrate ? `${(iface.bitrate / 1000).toFixed(0)} kbps` : 'N/A';
          const samplePointDisplay = iface.sample_point ? `${(iface.sample_point * 100).toFixed(1)}%` : 'N/A';

          leftColDiv.appendChild(createDetailParagraph('State:', statusText, `${statusColor} font-semibold`));
          leftColDiv.appendChild(createDetailParagraph('Bitrate:', bitrateDisplay));
          leftColDiv.appendChild(createDetailParagraph('Sample Point:', samplePointDisplay));
          leftColDiv.appendChild(createDetailParagraph('Restart MS:', iface.restart_ms === undefined ? 'N/A' : String(iface.restart_ms)));
          mainGridDiv.appendChild(leftColDiv);

          // Right Column (TQ, BRP, etc.)
          const rightColDiv = document.createElement('div');
          const tqDisplay = iface.tq ? `${iface.tq} ns` : 'N/A';
          rightColDiv.appendChild(createDetailParagraph('TQ:', tqDisplay));
          rightColDiv.appendChild(createDetailParagraph('BRP:', iface.brp === undefined ? 'N/A' : String(iface.brp)));
          rightColDiv.appendChild(createDetailParagraph('Prop Seg:', iface.prop_seg === undefined ? 'N/A' : String(iface.prop_seg)));
          rightColDiv.appendChild(createDetailParagraph('Phase Seg1:', iface.phase_seg1 === undefined ? 'N/A' : String(iface.phase_seg1)));
          rightColDiv.appendChild(createDetailParagraph('Phase Seg2:', iface.phase_seg2 === undefined ? 'N/A' : String(iface.phase_seg2)));
          rightColDiv.appendChild(createDetailParagraph('SJW:', iface.sjw === undefined ? 'N/A' : String(iface.sjw)));
          mainGridDiv.appendChild(rightColDiv);

          // Counters & Errors Section (Conditional)
          if (iface.tx_packets !== undefined || iface.rx_packets !== undefined || iface.tx_errors !== undefined || iface.restarts !== undefined) {
            const countersDiv = document.createElement('div');
            countersDiv.className = 'md:col-span-2 mt-3 pt-3 border-t border-gray-600';
            const countersH4 = document.createElement('h4');
            countersH4.className = 'text-md font-medium text-gray-300 mb-2';
            countersH4.textContent = 'Counters & Errors';
            countersDiv.appendChild(countersH4);
            const countersGrid = document.createElement('div');
            countersGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-1';
            countersGrid.appendChild(createDetailParagraph('TX Packets:', iface.tx_packets === undefined ? 'N/A' : String(iface.tx_packets)));
            countersGrid.appendChild(createDetailParagraph('RX Packets:', iface.rx_packets === undefined ? 'N/A' : String(iface.rx_packets)));
            countersGrid.appendChild(createDetailParagraph('TX Bytes:', iface.tx_bytes === undefined ? 'N/A' : String(iface.tx_bytes)));
            countersGrid.appendChild(createDetailParagraph('RX Bytes:', iface.rx_bytes === undefined ? 'N/A' : String(iface.rx_bytes)));
            countersGrid.appendChild(createDetailParagraph('TX Errors:', iface.tx_errors === undefined ? 'N/A' : String(iface.tx_errors)));
            countersGrid.appendChild(createDetailParagraph('RX Errors:', iface.rx_errors === undefined ? 'N/A' : String(iface.rx_errors)));
            countersGrid.appendChild(createDetailParagraph('Bus Errors:', iface.bus_errors === undefined ? 'N/A' : String(iface.bus_errors)));
            countersGrid.appendChild(createDetailParagraph('Restarts:', iface.restarts === undefined ? 'N/A' : String(iface.restarts)));
            countersDiv.appendChild(countersGrid);
            mainGridDiv.appendChild(countersDiv);
          }

          // Device Info Section (Conditional)
          if (iface.parentbus || iface.parentdev) {
            const devInfoDiv = document.createElement('div');
            devInfoDiv.className = 'md:col-span-2 mt-3 pt-3 border-t border-gray-600';
            const devInfoH4 = document.createElement('h4');
            devInfoH4.className = 'text-md font-medium text-gray-300 mb-2';
            devInfoH4.textContent = 'Device Info';
            devInfoDiv.appendChild(devInfoH4);
            const devInfoGrid = document.createElement('div');
            devInfoGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-1';
            devInfoGrid.appendChild(createDetailParagraph('Parent Bus:', iface.parentbus || 'N/A'));
            devInfoGrid.appendChild(createDetailParagraph('Parent Dev:', iface.parentdev || 'N/A'));
            devInfoDiv.appendChild(devInfoGrid);
            mainGridDiv.appendChild(devInfoDiv);
          }

          li.appendChild(mainGridDiv);
          ul.appendChild(li);
        }
        canStatusContainer.appendChild(ul);
      }

      // Helper function to create <p><strong>Label:</strong> Value</p> structure
      function createDetailParagraph(label, value, valueClass = '') {
        const p = document.createElement('p');
        p.className = 'mb-1';
        const strong = document.createElement('strong');
        strong.textContent = `${label} `;
        p.appendChild(strong);
        if (valueClass) {
          const span = document.createElement('span');
          span.className = valueClass;
          span.textContent = String(value);
          p.appendChild(span);
        } else {
          p.appendChild(document.createTextNode(String(value)));
        }
        return p;
      }

      // --- Fetch and Display API Server Status (NEW) ---
      async function fetchApiServerStatus() {
        if (!apiStatusContainer) return;
        apiStatusLoadingMessage.classList.remove('hidden'); // Show loading message
        try {
          const response = await fetch(`${apiBasePath}/status/server`);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }
          const statusData = await response.json();
          updateApiServerView(statusData);
        } catch (error) {
          console.error("Failed to fetch API server status:", error);
          if (apiStatusLoadingMessage) { // Check if it wasn't cleared by a successful load
            apiStatusLoadingMessage.textContent = 'Failed to load API server status.';
          }
          // Display error in the container itself if loading message is already gone or not primary
          apiStatusContainer.innerHTML = `<p class="text-red-400">Failed to load API server status: ${error.message}</p>`;
        } finally {
            if (apiStatusLoadingMessage) apiStatusLoadingMessage.classList.add('hidden'); // Hide loading message
        }
      }

      function updateApiServerView(statusData) {
        if (!apiStatusContainer) return;
        apiStatusContainer.innerHTML = ''; // Clear previous content

        const ul = document.createElement('ul');
        ul.className = 'space-y-2 text-sm';

        const items = {
          "Version": statusData.version,
          "Uptime": statusData.uptime,
          "Requests Processed": statusData.requests_processed,
          "Error Rate": statusData.error_rate
        };

        for (const [key, value] of Object.entries(items)) {
          const li = document.createElement('li');
          const strong = document.createElement('strong');
          strong.textContent = `${key}: `;
          li.appendChild(strong);
          li.appendChild(document.createTextNode(value || 'N/A'));
          ul.appendChild(li);
        }
        apiStatusContainer.appendChild(ul);
      }

      // --- Fetch and Display Application Health (NEW) ---
      async function fetchApplicationHealth() {
        if (!appHealthContainer) return;
        appHealthLoadingMessage.classList.remove('hidden'); // Show loading message
        try {
          const response = await fetch(`${apiBasePath}/status/application`);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }
          const healthData = await response.json();
          updateApplicationHealthView(healthData);
        } catch (error) {
          console.error("Failed to fetch application health:", error);
          if (appHealthLoadingMessage) { // Check if it wasn't cleared
            appHealthLoadingMessage.textContent = 'Failed to load application health.';
          }
          appHealthContainer.innerHTML = `<p class="text-red-400">Failed to load application health: ${error.message}</p>`;
        } finally {
            if (appHealthLoadingMessage) appHealthLoadingMessage.classList.add('hidden'); // Hide loading message
        }
      }

      function updateApplicationHealthView(healthData) {
        if (!appHealthContainer) return;
        appHealthContainer.innerHTML = ''; // Clear previous content

        const ul = document.createElement('ul');
        ul.className = 'space-y-2 text-sm';

        const healthItems = [
          { label: "Configuration Files Loaded", value: healthData.config_files_loaded ? 'Yes' : 'No', isGood: healthData.config_files_loaded },
          { label: "Active WebSocket Clients", value: healthData.websocket_clients === undefined ? 'N/A' : healthData.websocket_clients },
          { label: "Last Critical Error", value: healthData.last_error || 'N/A' }
          // Add more application-specific health indicators here by pushing to healthItems
        ];

        healthItems.forEach(item => {
          const li = document.createElement('li');
          const strong = document.createElement('strong');
          strong.textContent = `${item.label}: `;
          li.appendChild(strong);

          if (item.value !== undefined) {
            const span = document.createElement('span');
            span.textContent = String(item.value);
            if (typeof item.isGood === 'boolean') {
              span.className = item.isGood ? 'text-green-400' : 'text-red-400';
            }
            li.appendChild(span);
          } else {
            li.appendChild(document.createTextNode('N/A'));
          }
          ul.appendChild(li);
        });
        appHealthContainer.appendChild(ul);
      }

      // Helper function to call light services (or any entity control)
      function callLightService(entityId, command, data = {}) {
        let path;
        let body;
        const groupLightEntityIds = ['all_lights', 'exterior_lights', 'interior_lights']; // Add other group IDs if any

        if (groupLightEntityIds.includes(entityId)) {
          // This is a group control command
          const groupName = entityId.replace('_lights', ''); // e.g. all_lights -> all
          path = `${apiBasePath}/lights/control?group=${groupName}`;
          body = { command: command, ...data }; // Pass command and any relevant data (state, brightness)

          // Validate group commands (optional, but good practice for clarity)
          const validGroupCommands = ['set', 'toggle', 'brightness_up', 'brightness_down'];
          if (!validGroupCommands.includes(command)) {
            console.error(`Invalid command '${command}' for group light control '${entityId}'.`);
            showToast(`Invalid command for group ${entityId}`, 'error');
            return Promise.reject(`Invalid command for group ${entityId}`);
          }
          if (command === 'set' && data.state === undefined && data.brightness === undefined) {
            console.warn(`'set' command for group ${entityId} called without state or brightness.`);
            // Allow it, backend might handle it or have defaults, but it's unusual.
          }

        } else {
          // This is an individual entity control command
          path = `${apiBasePath}/entities/${entityId}/control`;
          body = { command: command, ...data }; // Standard body for entity control

          // Validate individual commands
          const validIndividualCommands = ['set', 'toggle', 'brightness_up', 'brightness_down'];
          if (!validIndividualCommands.includes(command)) {
            console.error('Unknown light command for individual entity:', command);
            showToast(`Unknown command: ${command} for ${entityId}`, 'error');
            return Promise.reject(`Unknown command: ${command} for ${entityId}`);
          }
        }

        return fetch(path, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(response => {
          if (!response.ok) {
            return response.json().then(err => {
              const errorMsg = `HTTP error ${response.status}: ${err.detail || response.statusText}`;
              console.error(`Service call for ${entityId} (${command}) failed:`, errorMsg, err);
              throw new Error(errorMsg);
            });
          }
          return response.json();
        })
        .then(responseData => {
          console.log(`Command ${command} for ${entityId} successful:`, responseData);
          // UI should update via WebSocket message triggering renderGroupedLights()
          // Or, if optimistic updates are desired, handle here.
        })
        .catch(error => {
          console.error(`Command ${command} for ${entityId} failed:`, error);
          showToast(`Failed to control ${entityId}: ${error.message}`, 'error');
        });
      }

      function renderCard(entity) {
        const card = document.createElement('div');
        card.className = 'p-4 rounded-lg shadow-md space-y-3 entity-card'; // Base classes
        card.dataset.entityId = entity.entity_id;

        const friendlyName = entity.friendly_name || entity.entity_id;
        let state = entity.state || 'unknown'; // 'on' or 'off'
        const raw_attrs = entity.raw || {}; // Use entity.raw for raw CAN values
        const capabilities = entity.capabilities || [];

        // Apply on/off class for styling
        if (state.toLowerCase() === 'on') {
          card.classList.add('light-on');
          card.classList.remove('light-off');
        } else {
          card.classList.add('light-off');
          card.classList.remove('light-on');
        }

        const h3 = document.createElement('h3');
        h3.className = 'text-lg font-semibold';
        h3.textContent = friendlyName;
        card.appendChild(h3);

        const hasBrightness = capabilities.includes('brightness');

        if (hasBrightness) {
          let currentBrightnessPercent = 0;
          if (state.toLowerCase() === 'on') {
            if (raw_attrs.operating_status !== undefined) {
              currentBrightnessPercent = Math.min(Math.round((parseInt(raw_attrs.operating_status, 10) / 200) * 100), 100);
            } else {
              currentBrightnessPercent = 100; // Default to 100% if on and no brightness attribute
            }
          }

          const brightnessControlDiv = document.createElement('div');
          brightnessControlDiv.className = 'brightness-control space-y-1 pt-2';

          const label = document.createElement('label');
          label.htmlFor = `br-${entity.entity_id}`;
          label.className = 'text-sm';
          label.textContent = 'Brightness: ';

          const brightnessValueSpan = document.createElement('span');
          brightnessValueSpan.id = `br-val-${entity.entity_id}`;
          brightnessValueSpan.textContent = `${currentBrightnessPercent}%`;
          label.appendChild(brightnessValueSpan);
          brightnessControlDiv.appendChild(label);

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.id = `br-${entity.entity_id}`;
          slider.dataset.entityId = entity.entity_id;
          slider.className = 'w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer brightness-slider';
          slider.min = '0';
          slider.max = '100';
          slider.value = String(currentBrightnessPercent);
          brightnessControlDiv.appendChild(slider);

          card.appendChild(brightnessControlDiv);

          // Add event listeners for the slider
          slider.addEventListener('input', (e) => {
            const brightness = parseInt(e.target.value, 10); // 0-100
            brightnessValueSpan.textContent = `${brightness}%`;
          });
          slider.addEventListener('change', (e) => { // 'change' event fires when user releases mouse
            const entityId = e.target.dataset.entityId;
            const brightness = parseInt(e.target.value, 10); // 0-100
            callLightService(entityId, 'set', { state: 'on', brightness: brightness });
          });
        }

        // Make the entire card clickable to toggle on/off
        card.addEventListener('click', (e) => {
          // Prevent toggle if the click was on the slider itself or its label or anything within brightness-control
          if (e.target.closest('.brightness-control')) {
            return;
          }
          const entityId = card.dataset.entityId;
          callLightService(entityId, 'toggle');
        });

        return card;
      }

      entitySocket.onmessage = (event) => {
        const entityData = JSON.parse(event.data);
        const entity_id = entityData.entity_id;

        if (entity_id) {
          // If the entity is already in lightStates (i.e., it's a light we are displaying), update it.
          if (lightStates.hasOwnProperty(entity_id)) {
            lightStates[entity_id] = entityData;
            renderGroupedLights();
          }
          // If it's a new entity that is a light (e.g., identified after initial load),
          // add it to lightStates and render.
          else if (entityData.device_type === 'light') {
            lightStates[entity_id] = entityData;
            // Check if its area needs to be added to the filter
            const area = entityData.suggested_area || 'Unknown';
            const areaFilter = document.getElementById('area-filter');
            if (areaFilter) {
              const existingOptions = Array.from(areaFilter.options).map(opt => opt.value);
              if (!existingOptions.includes(area)) {
                const opt = document.createElement('option');
                opt.value = area;
                opt.textContent = area;
                areaFilter.appendChild(opt);
                // Consider sorting filter options if many areas are dynamically added
              }
            }
            renderGroupedLights();
          }
        }
      };

      function renderGroupedLights() {
        console.log('renderGroupedLights called. lightStates:', JSON.parse(JSON.stringify(lightStates)), 'Filter:', filter ? filter.value : 'N/A');
        if (!grid) {
          console.error('renderGroupedLights: grid element not found!');
          return;
        }

        const lightsLoadingP = document.getElementById('lights-loading-message');
        if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
        }

        grid.innerHTML = ''; // Clear previous content (cards, "No lights" message, etc.)

        const selectedAreaFilter = filter.value;
        const groupedByArea = {};
        let lightsExistToDisplay = false;

        // Group lights by area, applying the filter
        for (const entityId in lightStates) {
          const entity = lightStates[entityId];
          if (entity.device_type === 'light') {
            const area = entity.suggested_area || 'Unknown';
            if (selectedAreaFilter === 'All' || selectedAreaFilter === area) {
              if (!groupedByArea[area]) {
                groupedByArea[area] = [];
              }
              groupedByArea[area].push(entity);
              lightsExistToDisplay = true;
            }
          }
        }

        if (!lightsExistToDisplay) {
          const messageP = document.createElement('p');
          messageP.className = 'text-gray-500 text-center py-8';
          if (Object.keys(lightStates).length === 0 && (!filter.value || filter.value === 'All')) {
            messageP.textContent = 'No lights are currently configured or available.';
            console.log('renderGroupedLights: Displaying "No lights configured" message.');
          } else {
            messageP.textContent = `No lights found for the current filter ("${selectedAreaFilter}").`;
            console.log(`renderGroupedLights: Displaying "No lights found for filter: ${selectedAreaFilter}" message.`);
          }
          grid.appendChild(messageP);
          return;
        }

        const sortedAreas = Object.keys(groupedByArea).sort();

        for (const areaName of sortedAreas) {
          const areaSectionDiv = document.createElement('div');
          areaSectionDiv.className = 'area-section mb-8';
          areaSectionDiv.dataset.areaName = areaName;

          const areaTitleH2 = document.createElement('h2');
          areaTitleH2.className = 'text-2xl font-semibold mb-3 text-gray-200';
          areaTitleH2.textContent = areaName;
          areaSectionDiv.appendChild(areaTitleH2);

          const dividerDiv = document.createElement('div');
          dividerDiv.className = 'border-t border-gray-700 mb-6';
          areaSectionDiv.appendChild(dividerDiv);

          const entitiesGridDiv = document.createElement('div');
          entitiesGridDiv.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 entity-grid';
          areaSectionDiv.appendChild(entitiesGridDiv);

          groupedByArea[areaName].forEach(entity => {
            try {
              const cardElement = renderCard(entity);
              if (cardElement) {
                entitiesGridDiv.appendChild(cardElement);
              } else {
                console.warn(`renderCard for entity ${entity.entity_id} returned null or undefined.`);
                const errorCardPlaceholder = document.createElement('div');
                errorCardPlaceholder.className = 'p-4 rounded-lg shadow-md entity-card bg-yellow-700 text-white';
                errorCardPlaceholder.textContent = `Could not render ${entity.friendly_name || entity.entity_id}. See console.`;
                entitiesGridDiv.appendChild(errorCardPlaceholder);
              }
            } catch (e) {
              console.error(`Error rendering card for entity ${entity.entity_id} (Area: ${areaName}):`, e);
              const errorCardPlaceholder = document.createElement('div');
              errorCardPlaceholder.className = 'p-4 rounded-lg shadow-md entity-card bg-red-800 text-white';
              errorCardPlaceholder.textContent = `Error loading ${entity.friendly_name || entity.entity_id}. Check console.`;
              entitiesGridDiv.appendChild(errorCardPlaceholder);
            }
          });
          grid.appendChild(areaSectionDiv);
        }
        console.log('renderGroupedLights: Finished rendering areas and cards.');
      }

      // Fetch initial light states
      fetch(`${apiBasePath}/lights`)
        .then(res => {
          if (!res.ok) {
            return res.text().then(text => {
              throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}. Response: ${text}`);
            });
          }
          return res.json();
        })
        .then(data => {
          const lightsLoadingP = document.getElementById('lights-loading-message');
          if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
          }
          if (data && Array.isArray(data)) {
            data.forEach(entity => {
              if (entity.device_type === 'light') {
                lightStates[entity.entity_id] = entity;
                const area = entity.suggested_area || 'Unknown';
                const areaFilter = document.getElementById('area-filter');
                if (areaFilter) {
                    const existingOptions = Array.from(areaFilter.options).map(opt => opt.value);
                    if (!existingOptions.includes(area)) {
                        const opt = document.createElement('option');
                        opt.value = area;
                        opt.textContent = area;
                        areaFilter.appendChild(opt);
                    }
                }
              }
            });
          } else if (data) {
            console.warn("Received non-array data for lights:", data);
          }
          renderGroupedLights();
        })
        .catch(error => {
          console.error("Failed to fetch lights:", error);
          const lightsLoadingP = document.getElementById('lights-loading-message');
          if (lightsLoadingP) {
            lightsLoadingP.classList.add('hidden');
          }
          if (grid) {
            grid.innerHTML = `<p class="text-red-500 text-center py-8">Error loading lights: ${error.message}. Check console for details.</p>`;
          }
        });

      document.querySelectorAll('.nav-link').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.getAttribute('data-view');

          // If a main view navigation occurs, and logs are open, ensure logs remain visible
          // The pinned log pane is independent of view sections now.

          document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
          const targetView = document.getElementById(`${view}-view`);
          if (targetView) {
            targetView.classList.remove('hidden');
          } else {
            console.error(`View section not found: ${view}-view`);
            const homeViewFallback = document.getElementById('home-view');
            if (homeViewFallback) homeViewFallback.classList.remove('hidden');
            // If home is fallback, ensure its nav link is active
            const homeNavLinkFallback = document.querySelector('.nav-link[data-view="home"]');
            if (homeNavLinkFallback) {
                document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
                homeNavLinkFallback.classList.add('active-nav');
            }
            return;
          }

          document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
          btn.classList.add('active-nav');

          // Remove specific logic for 'logs' view as it's now pinned
          // if (view === 'logs') { ... } else { disconnectLogSocket(); ... }

          if (view === 'mapping') {
            fetch(`${apiBasePath}/config/device_mapping`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('mapping-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch device_mapping.yml:", err);
                document.getElementById('mapping-content').textContent = `Error: Could not load device_mapping.yml.\n${err.message}`;
              });
          } else if (view === 'spec') {
            fetch(`${apiBasePath}/config/rvc_spec`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.text();
              })
              .then(text => {
                document.getElementById('spec-content').textContent = text;
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json:", err);
                document.getElementById('spec-content').textContent = `Error: Could not load rvc.json.\n${err.message}`;
              });
            fetch(`${apiBasePath}/config/rvc_spec_metadata`)
              .then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status} - ${res.statusText}`);
                return res.json();
              })
              .then(data => {
                const metadataDiv = document.getElementById('spec-metadata');
                if (data.version && data.spec_document) {
                  metadataDiv.innerHTML = `
                    <p><strong>Version:</strong> ${data.version}</p>
                    <p><strong>Document:</strong> <a href="${data.spec_document}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:text-blue-300 underline">${data.spec_document}</a></p>
                  `;
                } else if (data.spec_document) { // Case where only document is present
                  metadataDiv.innerHTML = `
                    <p><strong>Document:</strong> <a href="${data.spec_document}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:text-blue-300 underline">${data.spec_document}</a></p>
                  `;
                }
                else {
                  metadataDiv.textContent = 'Could not load spec metadata.';
                }
              })
              .catch(err => {
                console.error("Failed to fetch rvc.json metadata:", err);
                document.getElementById('spec-metadata').textContent = `Error: Could not load spec metadata. ${err.message}`;
              });
          } else if (view === 'unmapped') {
            const container = document.getElementById('unmapped-entries-container');
            const loadingMsg = document.getElementById('unmapped-loading-message');
            loadingMsg.classList.remove('hidden');
            container.innerHTML = ''; // Clear previous entries
            container.appendChild(loadingMsg);

            fetch(`${apiBasePath}/unmapped_entries`)
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                return response.json();
              })
              .then(data => {
                loadingMsg.classList.add('hidden');
                if (Object.keys(data).length === 0) {
                  container.innerHTML = '<p class="text-gray-500">No unmapped entries found. Good job!</p>';
                  return;
                }

                for (const [key, entry] of Object.entries(data)) {
                  const entryDiv = document.createElement('div');
                  entryDiv.className = 'bg-gray-800 p-4 rounded-lg shadow';

                  // Header: DGN and Instance
                  const header = document.createElement('h4');
                  header.className = 'text-lg font-semibold text-yellow-300 mb-2';
                  header.textContent = `DGN: ${entry.dgn_hex}${entry.dgn_name ? ' (' + entry.dgn_name + ')' : ''} - Instance: ${entry.instance}`;
                  entryDiv.appendChild(header);

                  // Details List
                  const detailsList = document.createElement('ul');
                  detailsList.className = 'list-disc list-inside space-y-1 text-sm mb-3';

                  function addDetailItem(label, value) {
                    const item = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = `${label}: `;
                    item.appendChild(strong);
                    item.appendChild(document.createTextNode(value));
                    detailsList.appendChild(item);
                  }

                  if (entry.pgn_hex && entry.pgn_hex !== entry.dgn_hex) {
                    addDetailItem('Original PGN', `${entry.pgn_hex}${entry.pgn_name ? ' (' + entry.pgn_name + ')' : ''}`);
                  }
                  addDetailItem('First Seen', new Date(entry.first_seen_timestamp * 1000).toLocaleString());
                  addDetailItem('Last Seen', new Date(entry.last_seen_timestamp * 1000).toLocaleString());
                  addDetailItem('Count', entry.count);
                  addDetailItem('Last Data', entry.last_data_hex);
                  if (entry.spec_entry && entry.spec_entry.name) {
                    addDetailItem('Matched Spec Entry Name (for DGN)', entry.spec_entry.name);
                  }
                  entryDiv.appendChild(detailsList);

                  // Decoded Signals (if any)
                  if (entry.decoded_signals && Object.keys(entry.decoded_signals).length > 0) {
                    const signalsHeader = document.createElement('h5');
                    signalsHeader.className = 'text-md font-medium text-gray-300 mt-2 mb-1';
                    signalsHeader.textContent = `Decoded Signals (from PGN ${entry.pgn_hex}):`;
                    entryDiv.appendChild(signalsHeader);
                    const signalsList = document.createElement('ul');
                    signalsList.className = 'list-disc list-inside pl-4 space-y-0.5 text-xs';
                    for (const [key, value] of Object.entries(entry.decoded_signals)) {
                      const signalItem = document.createElement('li');
                      signalItem.innerHTML = `<strong>${key}:</strong> ${value}`; // Using innerHTML here for simplicity, assuming key/value are safe
                      signalsList.appendChild(signalItem);
                    }
                    entryDiv.appendChild(signalsList);
                  }

                  // Suggestions (if any)
                  if (entry.suggestions && entry.suggestions.length > 0) {
                    const suggestionsHeader = document.createElement('h5');
                    suggestionsHeader.className = 'text-md font-medium text-gray-300 mt-3 mb-1';
                    suggestionsHeader.textContent = 'Suggestions:';
                    entryDiv.appendChild(suggestionsHeader);
                    const suggestionsList = document.createElement('ul');
                    suggestionsList.className = 'list-disc list-inside pl-4 space-y-0.5 text-xs';
                    entry.suggestions.forEach(suggestion => {
                      const suggestionItem = document.createElement('li');
                      suggestionItem.textContent = suggestion;
                      suggestionsList.appendChild(suggestionItem);
                    });
                    entryDiv.appendChild(suggestionsList);
                  }

                  // YAML Suggestion
                  const yamlSuggestion = generateYamlSuggestion(entry);
                  const yamlHeader = document.createElement('h5');
                  yamlHeader.className = 'text-md font-medium text-gray-300 mt-3 mb-1';
                  yamlHeader.textContent = 'YAML Suggestion for device_mapping.yml:';
                  entryDiv.appendChild(yamlHeader);

                  const pre = document.createElement('pre');
                  pre.className = 'bg-gray-900 text-green-300 p-3 rounded overflow-auto text-xs font-mono whitespace-pre-wrap';
                  pre.textContent = yamlSuggestion;
                  entryDiv.appendChild(pre);

                  const copyButton = document.createElement('button');
                  copyButton.className = 'copy-yaml-btn mt-2 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold py-1 px-3 rounded shadow';
                  copyButton.innerHTML = '<i class="mdi mdi-content-copy mr-1" aria-hidden="true"></i>Copy YAML'; // Icon added
                  copyButton.addEventListener('click', () => {
                    navigator.clipboard.writeText(pre.textContent)
                      .then(() => showToast('YAML copied to clipboard!', 'success'))
                      .catch(err => {
                        console.error('Failed to copy YAML: ', err);
                        showToast('Failed to copy YAML.', 'error');
                      });
                  });
                  entryDiv.appendChild(copyButton);
                  container.appendChild(entryDiv);
                }
                // Event listeners for copy buttons are now added individually when button is created.
              })
              .catch(error => {
                console.error('Error fetching unmapped entries:', error);
                loadingMsg.classList.add('hidden');
                container.innerHTML = `<p class="text-red-500">Error loading unmapped entries: ${error.message}</p>`;
              });
          }
          // --- START: Add logic for Unknown PGNs view ---
          else if (view === 'unknown-pgns') {
            const container = document.getElementById('unknown-pgns-container');
            const loadingMsg = document.getElementById('unknown-pgns-loading-message');
            loadingMsg.classList.remove('hidden');
            container.innerHTML = ''; // Clear previous entries
            container.appendChild(loadingMsg);

            fetch(`${apiBasePath}/unknown_pgns`)
              .then(response => {
                if (!response.ok) { // Check if response is ok
                  throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                }
                return response.json();
              })
              .then(data => {
                loadingMsg.classList.add('hidden');
                if (Object.keys(data).length === 0) {
                  container.innerHTML = '<p class="text-gray-500">No unknown PGNs found. All observed PGNs are in rvc.json.</p>';
                  return;
                }

                for (const [arbIdHex, entry] of Object.entries(data)) {
                  const entryDiv = document.createElement('div');
                  entryDiv.className = 'bg-gray-800 p-4 rounded-lg shadow';

                  const header = document.createElement('h4');
                  header.className = 'text-lg font-semibold text-red-300 mb-2';
                  header.textContent = `Arbitration ID: ${arbIdHex} (PGN: ${entry.pgn_hex || 'N/A'})`;
                  entryDiv.appendChild(header);

                  const detailsList = document.createElement('ul');
                  detailsList.className = 'list-disc list-inside space-y-1 text-sm';

                  function addDetailItem(label, value) {
                    const item = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = `${label}: `;
                    item.appendChild(strong);
                    item.appendChild(document.createTextNode(value));
                    detailsList.appendChild(item);
                  }

                  addDetailItem('Source Address', entry.source_address_hex || 'N/A');
                  addDetailItem('Count', entry.count);
                  addDetailItem('First Seen', new Date(entry.first_seen_timestamp * 1000).toLocaleString());
                  addDetailItem('Last Seen', new Date(entry.last_seen_timestamp * 1000).toLocaleString());
                  addDetailItem('Last Data', entry.last_data_hex);

                  entryDiv.appendChild(detailsList);
                  container.appendChild(entryDiv);
                }
              })
              .catch(error => {
                console.error('Error fetching unknown PGNs:', error);
                loadingMsg.classList.add('hidden');
                container.innerHTML = `<p class="text-red-500">Error loading unknown PGNs: ${error.message}</p>`;
              });
            }
          // --- END: Add logic for Unknown PGNs view ---
          // Add this else if block to handle fetching CAN status when home is selected
          else if (view === 'home') {
            fetchCanStatus(); // Re-fetch CAN status when navigating to home
          }
        });
      });

      // Function to generate YAML suggestion
      function generateYamlSuggestion(entry) {
        const dgnKey = entry.dgn_hex; // Use DGN for the mapping file key
        const instanceKey = String(entry.instance); // Instance ID

        // Create a sanitized entity_id suggestion
        const dgnForId = dgnKey.toLowerCase();
        const instanceForId = instanceKey.toLowerCase().replace(/[^a-z0-9_]/g, ''); // Basic sanitize
        let suggestedEntityId = `unmapped_${dgnForId}_inst${instanceForId}`;

        let yaml = `# Suggested entry for DGN: ${dgnKey}${entry.dgn_name ? ' (' + entry.dgn_name + ')' : ''}, Instance: ${instanceKey}\n`;
        if (entry.pgn_hex && entry.pgn_hex !== entry.dgn_hex) {
          yaml += `# Original PGN from Arbitration ID: ${entry.pgn_hex}${entry.pgn_name ? ' (' + entry.pgn_name + ')' : ''}\n`;
        }
        yaml += `# First seen: ${new Date(entry.first_seen_timestamp * 1000).toLocaleString()}\n`;
        yaml += `# Last seen: ${new Date(entry.last_seen_timestamp * 1000).toLocaleString()}\n`;
        yaml += `# Count: ${entry.count}\n`;
        yaml += `# Last Data: ${entry.last_data_hex}\n`;

        if (entry.decoded_signals && Object.keys(entry.decoded_signals).length > 0) {
          yaml += `# Decoded Signals (from PGN ${entry.pgn_hex}):\n`;
          for (const [key, value] of Object.entries(entry.decoded_signals)) {
            yaml += `#   ${key}: ${value}\n`;
          }
        }
        if (entry.spec_entry && entry.spec_entry.name) {
            yaml += `# Matched Spec Entry Name (for DGN): ${entry.spec_entry.name}\n`;
        }
        yaml += `\n`; // Blank line for readability before the YAML structure

        // Start of the structured YAML suggestion
        yaml += `${dgnKey}:\n`;
        yaml += `  ${instanceKey}:\n`; // Instance ID as a key (e.g., 255: or "default":)
        yaml += `    - entity_id: "${suggestedEntityId}" # TODO: MUST be unique. Change to a descriptive name (e.g., 'living_room_thermostat')\n`;
        yaml += `      friendly_name: "Unmapped ${entry.dgn_name || dgnKey} Inst ${instanceKey}" # TODO: Set a user-friendly name (e.g., 'Living Room Thermostat')\n`;
        yaml += `      suggested_area: "Unknown Area" # TODO: Assign an area (e.g., 'Living Room', 'Bedroom')\n`;
        yaml += `      device_type: "unknown" # TODO: Specify type (e.g., light, sensor, hvac, lock, switch, tank)\n`;
        yaml += `      capabilities: [] # TODO: Define capabilities (e.g., [on_off], [on_off, brightness], [lock_unlock], [temperature])\n`;
        yaml += `      # --- Optional fields based on device_type and system needs ---\n`;
        yaml += `      # interface: canX # TODO: Specify CAN interface if known (e.g., can0, can1)\n`;
        yaml += `      # status_dgn: '${dgnKey}' # Status DGN is typically this DGN key\n`;
        yaml += `      # command_pgn: 'YYYYY' # TODO: If controllable and different from status DGN, specify command PGN\n`;
        yaml += `      # group_mask: '0xXX' # TODO: If part of a command/status group\n`;
        yaml += `      # --- Example for using a YAML template (if defined in your mapping file) ---\n`;
        yaml += `      # <<: *switchable_light  # For on/off lights, if &switchable_light template exists\n`;
        yaml += `      # <<: *dimmable_light   # For dimmable lights, if &dimmable_light template exists\n`;

        return yaml;
      }

      // Sidebar toggle logic
      const sidebar = document.getElementById('sidebar');
      const mobileMenuButton = document.getElementById('mobileMenuButton');
      const closeSidebarButton = document.getElementById('closeSidebarButton');
      const toggleSidebarDesktopButton = document.getElementById('toggleSidebarDesktop');
      const desktopSidebarVisibleKey = 'desktopSidebarVisible';
      const sidebarNavContent = document.getElementById('sidebarNavContent');

      function setDesktopSidebarVisible(visible) {
        console.log('[setDesktopSidebarVisible] Called with visible:', visible);
        localStorage.setItem(desktopSidebarVisibleKey, visible);
        if (visible) { // EXPANDING
          console.log('[setDesktopSidebarVisible] Expanding sidebar.');
          sidebar.classList.remove('md:w-16'); // Remove collapsed width
          sidebar.classList.add('md:w-64');    // Add expanded width
          mainContent.classList.remove('md:ml-16');
          mainContent.classList.add('md:ml-64');
          toggleSidebarDesktopButton.innerHTML = '<i class="mdi mdi-chevron-left text-xl"></i> <span class="ml-2">Collapse</span>';
          if (sidebarNavContent) sidebarNavContent.classList.remove('hidden');
          sidebar.classList.remove('sidebar-collapsed-hoverable'); // Remove hover indication class
        } else { // COLLAPSING
          console.log('[setDesktopSidebarVisible] Collapsing sidebar.');
          sidebar.classList.remove('md:w-64');  // Remove expanded width
          sidebar.classList.add('md:w-16');   // Add collapsed width (e.g., 4rem)
          mainContent.classList.remove('md:ml-64');
          mainContent.classList.add('md:ml-16'); // Adjust main content margin to collapsed width
          toggleSidebarDesktopButton.innerHTML = '<i class="mdi mdi-chevron-right text-xl"></i>'; // Icon only for collapsed state
          if (sidebarNavContent) sidebarNavContent.classList.add('hidden');
          sidebar.classList.add('sidebar-collapsed-hoverable'); // Add hover indication class
        }
        console.log('[setDesktopSidebarVisible] Requesting adjustPinnedLogsLayout via rAF.');
        requestAnimationFrame(() => {
          console.log('[setDesktopSidebarVisible] Executing adjustPinnedLogsLayout via rAF from setDesktopSidebarVisible.');
          adjustPinnedLogsLayout();
        });
      }

      // Mobile sidebar toggle
      mobileMenuButton.addEventListener('click', () => {
        sidebar.classList.remove('-translate-x-full');
        sidebar.classList.add('translate-x-0');
        // Optionally add an overlay for mobile
        // const overlay = document.createElement('div');
        // overlay.id = 'sidebar-overlay';
        // overlay.className = 'fixed inset-0 bg-black opacity-50 z-30 md:hidden';
        // document.body.appendChild(overlay);
        // overlay.addEventListener('click', () => toggleMobileSidebar(false));
      });

      closeSidebarButton.addEventListener('click', () => {
        sidebar.classList.add('-translate-x-full');
        sidebar.classList.remove('translate-x-0');
        // const overlay = document.getElementById('sidebar-overlay');
        // if (overlay) overlay remove();
      });

      // Desktop sidebar toggle
      toggleSidebarDesktopButton.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent click from bubbling to the parent sidebar element
        const isVisible = sidebar.classList.contains('md:w-64'); // Check if expanded
        console.log('[SidebarToggle] Button clicked. Currently isVisible (expanded):', isVisible);
        setDesktopSidebarVisible(!isVisible);
      });

      // Allow clicking the entire collapsed sidebar pane to expand it on desktop
      sidebar.addEventListener('click', () => {
        const isCollapsedDesktop = window.innerWidth >= 768 && sidebar.classList.contains('md:w-16');
        console.log('[SidebarClick] Sidebar area clicked. isCollapsedDesktop:', isCollapsedDesktop);
        if (isCollapsedDesktop) {
          setDesktopSidebarVisible(true);
        }
      });

      // Initialize sidebar state from localStorage for desktop
      const storedState = localStorage.getItem(desktopSidebarVisibleKey);
      if (storedState === 'false') {
        setDesktopSidebarVisible(false);
      } else { // null, 'true', or any other value defaults to visible
        setDesktopSidebarVisible(true);
      }

      // Close mobile sidebar when a nav link is clicked
      document.querySelectorAll('#sidebar .nav-link').forEach(link => {
        link.addEventListener('click', () => {
          if (window.innerWidth < 768) { // Tailwind's 'md' breakpoint
            sidebar.classList.add('-translate-x-full');
            sidebar.classList.remove('translate-x-0');
            // const overlay = document.getElementById('sidebar-overlay');
            // if (overlay) overlay remove();
          }
        });
      });

      // Set default view and initialize components
      document.addEventListener('DOMContentLoaded', () => {
        // Set "Home" as the default view
        document.querySelectorAll('.view-section').forEach(sec => sec.classList.add('hidden'));
        const homeView = document.getElementById('home-view');
        const homeNavLink = document.querySelector('.nav-link[data-view="home"]');

        if (homeView) {
          homeView.classList.remove('hidden');
          document.querySelectorAll('.nav-link').forEach(b => b.classList.remove('active-nav'));
          if (homeNavLink) homeNavLink.classList.add('active-nav');
        } else {
          // Fallback if home-view is not found, show the first available view (e.g. lights)
          const lightsView = document.getElementById('lights-view');
          const lightsNavLink = document.querySelector('.nav-link[data-view="lights"]');
          if (lightsView) lightsView.classList.remove('hidden');
          if (lightsNavLink) lightsNavLink.classList.add('active-nav');
        }

        // Any other initializations that need to happen after DOM is ready
        // For example, if you still need to fetch initial data for other views:
        // fetchInitialDataForOtherViews();

        // THE REDUNDANT LISTENER BLOCK PREVIOUSLY HERE HAS BEEN REMOVED.

        // Setup interval to refresh CAN status periodically if desired
        // setInterval(fetchCanStatus, 30000); // Refresh every 30 seconds, for example

        // --- Add Event Listeners for Quick Light Controls ---
        const quickControlButtons = [
          { id: 'btn-all-on', entityId: 'all_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-all-off', entityId: 'all_lights', command: 'set', data: { state: 'off' } },
          { id: 'btn-exterior-on', entityId: 'exterior_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-exterior-off', entityId: 'exterior_lights', command: 'set', data: { state: 'off' } },
          { id: 'btn-interior-on', entityId: 'interior_lights', command: 'set', data: { state: 'on' } },
          { id: 'btn-interior-off', entityId: 'interior_lights', command: 'set', data: { state: 'off' } },
        ];

        quickControlButtons.forEach(control => {
          const button = document.getElementById(control.id);
          if (button) {
            button.addEventListener('click', () => {
              // Temporarily disable button and show loading state
              const originalHtml = button.innerHTML;
              button.disabled = true;
              // Ensure the loading icon is an <i> tag if using MDI
              button.innerHTML = '<i class="mdi mdi-loading mdi-spin mr-2"></i>Processing...';

              callLightService(control.entityId, control.command, control.data)
                .then(response => {
                  // Assuming callLightService resolves with response data on success
                  // And responseData might have a message or status to show
                  let toastMessage = `${control.id.replace('btn-', '').replace('-', ' ')} command sent.`;
                  if (response && response.message) {
                    toastMessage = response.message;
                  } else if (response && response.status) {
                     toastMessage = `Status: ${response.status}`;
                  }
                  showToast(toastMessage, 'success');
                })
                .catch(error => {
                  // Error is already shown by showToast in callLightService,
                  // but we log it here for button-specific context if needed.
                  console.error(`Quick control for ${control.entityId} (button ${control.id}) failed:`, error);
                  // showToast is already called by callLightService on error.
                })
                .finally(() => {
                  button.disabled = false;
                  button.innerHTML = originalHtml;
                });
            });
          } else {
            console.warn(`Quick control button with ID ${control.id} not found.`);
          }
        });

        // --- End of Added Event Listeners for Quick Light Controls ---

        // Initial data fetches
        fetchCanStatus(); // Existing
        fetchApiServerStatus(); // New
        fetchApplicationHealth(); // New

        // Setup periodic refresh for status sections (optional, adjust intervals as needed)
        setInterval(fetchCanStatus, 10000); // Refresh CAN status every 10 seconds
        setInterval(fetchApiServerStatus, 30000); // Refresh API status every 30 seconds
        setInterval(fetchApplicationHealth, 30000); // Refresh App health every 30 seconds

        // Add event listeners for log control buttons
        if (logPauseBtn) {
          logPauseBtn.addEventListener('click', () => {
            isLogPaused = true;
            logPauseBtn.disabled = true;
            logResumeBtn.disabled = false;
            showToast('Log streaming paused.', 'info');
          });
        }

        if (logResumeBtn) {
          logResumeBtn.addEventListener('click', () => {
            isLogPaused = false;
            logPauseBtn.disabled = false;
            logResumeBtn.disabled = true;
            showToast('Log streaming resumed.', 'info');
            // If connection was closed and we are resuming, try to reconnect
            if (!logSocket || logSocket.readyState === WebSocket.CLOSED) {
              connectLogSocket();
            }
          });
        }

        if (logClearBtn) {
          logClearBtn.addEventListener('click', () => {
            logStream.innerHTML = '';
            showToast('Logs cleared.', 'info');
          });
        }

        // Add event listeners for log filters
        if (logLevelFilter) {
          logLevelFilter.addEventListener('change', () => {
              logStream.innerHTML = ''; // Clear logs when filter changes, as past logs might not match
              // Or, re-filter existing logs if desired (more complex)
              if (logSocket && logSocket.readyState === WebSocket.OPEN && !isLogPaused) {
                  // If connected and not paused, new logs will adhere to the filter.
                  // Consider if a re-fetch or re-display of buffered/past logs is needed.
              }
          });
        }
        if (logSearchInput) {
          logSearchInput.addEventListener('input', () => {
              // Similar to level filter, might want to clear or re-filter existing logs.
              // For simplicity, new logs will be filtered. Real-time re-filtering is more complex.
              // Throttling this event might be good for performance if re-filtering live.
          });
        }

        // --- START: Create New Scene Button Listener ---
        const createSceneButton = document.getElementById('btn-create-scene');
        if (createSceneButton) {
          createSceneButton.addEventListener('click', () => {
            alert('Create New Scene button clicked! Feature coming soon.');
            // Potentially call showToast here instead of alert
            // showToast('Scene creation functionality is under development.', 'info', 4000);
          });
        }
        // --- END: Create New Scene Button Listener ---

        // Theme switcher
        const themeSwitcher = document.getElementById('themeSwitcher');
        const THEME_KEY = 'selectedTheme';
        const VALID_THEMES = ['default', 'dark', 'light', 'catppuccin-mocha', 'catppuccin-latte'];

        function applyTheme(theme) {
          let currentTheme = theme;
          if (typeof currentTheme !== 'string' || !VALID_THEMES.includes(currentTheme)) {
            console.warn(`Invalid theme value received: "${currentTheme}". Defaulting to 'default'.`);
            currentTheme = 'default';
          }

          document.body.classList.remove(...VALID_THEMES.map(t => `theme-${t}`));
          document.body.classList.add(`theme-${currentTheme}`);
          localStorage.setItem(THEME_KEY, currentTheme);

          if (themeSwitcher) {
            themeSwitcher.value = currentTheme;
          } else {
            // This case should ideally be caught by the check below before calling applyTheme initially
            // or before adding the event listener.
            console.warn('applyTheme called but themeSwitcher element not found when trying to set its value.');
          }
        }

        if (themeSwitcher) {
          themeSwitcher.addEventListener('change', (event) => {
            applyTheme(event.target.value);
          });

          // Load saved theme on page load
          const savedTheme = localStorage.getItem(THEME_KEY);
          // applyTheme will validate and default if savedTheme is null or invalid
          applyTheme(savedTheme);
        } else {
          console.error("Theme switcher element 'themeSwitcher' not found! Theme functionality will be impaired.");
          // Fallback to default theme if switcher is missing, so the page is at least styled consistently.
          // This call to applyTheme won't be able to set themeSwitcher.value, but will set body class and localStorage.
          applyTheme('default');
        }
      });

      // Adjust logs layout on window resize (e.g., crossing mobile/desktop breakpoint)
      window.addEventListener('resize', adjustPinnedLogsLayout);

      // --- START: WebSocket Cleanup on Page Unload ---
      window.addEventListener('beforeunload', () => {
        console.log('Closing WebSockets before page unload...');
        if (logSocket) {
          logSocket.close();
          console.log('Log WebSocket closed.');
        }
        if (entitySocket) {
          entitySocket.close();
          console.log('Entity WebSocket closed.');
        }
      });
      // --- END: WebSocket Cleanup on Page Unload ---

    })(); // END IIFE
        </script>
    </body>
</html>
